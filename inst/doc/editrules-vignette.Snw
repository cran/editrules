%\VignetteIndexEntry{Editrules, define and check linear data restrictions}
\documentclass[10pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}
 


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}


\title{Linear edit manipulation and error localization with the {\tt editrules} package}
\author{Edwin de Jonge and Mark van der Loo}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 1.0 fo the package will have
the full vignette.}
\end{abstract}

<<echo=FALSE, keep.source=FALSE>>=
library(editrules)
@
\maketitle

\tableofcontents
\newpage

\section{Introduction}
The value domain of real numerical data records with $n$ variables is often restricted
to a subdomain of $\mathbb{R}^n$ due to linear equality and inequality relations
which the variables in the record have to obey. Examples include equality restrictions imposed
by financial balance accounts, positivity demands on certain variables or limits on the
ratio of variables.

Any such restriction is of the form
\begin{equation}
\label{edit}
{\bf a}\cdot{\bf x} \odot b\textrm{ with }\odot\in\{<,\leq,=\},
\end{equation}
where $\bf x$ is a numerical data record, ${\bf a}$, ${\bf x}\in \mathbb{R}^n$
and $b\in \mathbb{R}$. In data editing literature, data restriction rules
are refered to as {\em edits}, or {\em edit rules}. We will call edits, written
in the form of Eq.\ \eqref{edit}, edits in {\em normal form}. 

Large complex surveys are often endowed with dozens or even hundreds of edit
rules.  For example, the Dutch Structural Business Survey, which aims to report
on the financial structure of companies in the Netherlands, contains on the
order of 100 variables, endowed with a similar number of linear equality and
inequality restrictions.

Defining and manipulating large edit sets can be a daunting task , while 
edit violations gives rise to the error localization problem, which can quite
simply be stated as {\em which variables contain the errors that cause a record to violate certain
edits rules?}.

The {\tt editrules} package for the R statistical computing environment
\citep{R-core:2011} aims to provide an environment to conveniently define,
parse and check linear (in)equality restrictions, perform common edit
manipulations and offer error localization functionality based on the
(generalized) paradigm of \cite{fellegi:1976}. This paradigm is based on the
assumption that errors are distributed randomly over the variables, and there
is no detectable cause of error. The paradigm also decouples the detection from
correction of corrupt variables. Certain causes of error, such as sign flips,
typing errors or rounding errors can be detected and are closely related to
their resolution. The reader is referred to the {\tt deducorrect} package
\citep{loo:2011, scholtus:2008, scholtus:2009} for treating such errors. 

The following chapters demonstrates the functionality of the {\tt editrules}
package with coded examples as well a description of of the underlying theory and
algorithms. For a detailed per-function description the reader is referred to
the reference manual accompanying the package. Unless mentioned otherwise,
all code shown in this paper can be executed from the R commandline after loading
the {\tt editrules} package.


\section{Defining and checking numerical restrictions}

\subsection{The {\tt editmatrix} object}
For computational processing, a set of edits of the form 
\begin{equation}
{\bf a}\cdot{\bf x} \odot b\textrm{ with }\odot\in\{<,\leq,=,\geq,>\}.
\label{nonnormaledit}
\end{equation}
is most conveniently represented as a matrix.  In the {\tt editrules} package,
a set of linear edits is stored as an {\tt editmatrix} object.  This 
object stores the linear relations as an augmented matrix $[{\bf
A},{\bf b}]$, where $\bf A$ is the matrix obtained by combining the  ${\bf a}$
vecors of Eq.\ \eqref{nonnormaledit} in rows of $\bf A$ and constants  $b$ in $\bf b$. A
second attribute holds the comparison operators as a {\tt character} vector.
Formally, we denote that every {\tt editmatrix} $E$ is defined by
\begin{equation}
E = \left\langle [\mathbf{A},\mathbf{b}],\boldsymbol{\odot}\right\rangle 
\textrm{ with } [{\bf A},{\bf b}]\in \mathbb{R}^{m\times{n+1}},\:
\boldsymbol{\odot}\in\{<,\leq,=,\geq,>\}^{m},
\label{editset}
\end{equation}
where $n$ is the number of variables, $m$ the number of edit rules and the notation
$\langle \:,\:\rangle$ denotes a combination of objects.
Retrieval functions for various parts of an {\tt editmatrix} are available, 
see Table \ref{simplemanipulations} (p.\ \pageref{simplemanipulations}) for an overview.
Defining augmented matrices by hand is tedious and prone to error, which is why
the {\tt editmatrix} function  derives edit matrices from a textual representation
of edit rules. Since most functions of the {\tt editrules} package expect an 
{\tt editmatrix} in normal form (that is $\boldsymbol{\odot}\in\{<,\leq,=\}$), the {\tt editmatrix}
function by default transforms all linear edits to normal form.

As an example, consider the set of variables
\begin{center}
\begin{tabular}{ll}
turnover       & $t$ \\
personell cost & $c_p$\\
housing cost   & $c_h$\\
total cost     & $c_t$\\
profit         & $p$, \\
\end{tabular}
\end{center}
subject to the rules
\begin{eqnarray}
\label{e1}
t   &=& c_t + p\\
c_t &=& c_h + c_p\\ 
p &\leq& 0.6t\\
c_t &\leq& 0.3t\\
c_p&\leq& 0.3t\\
t   &>& 0\\
c_h &>& 0\\
c_p &>& 0\\
\label{e9}
c_t &>& 0.
\end{eqnarray}
Clearly, these can be written in the form of Eq.\ \eqref{edit}.  Here, the
equality restrictions correspond to balance accounts, the 3rd, 4th and 5th
restrictions are sanity checks and the last four edits demand positivity.  
Figure \ref{emfromtext} shows how these edit rules can be
transformed from a textual representation to a matrix representation with the
{\tt editmatrix} function.
%
\begin{Rcode}
<<keep.source=true>>=
E <- editmatrix(c(
"t  == ct + p" ,
"ct == ch + cp",
"p  <= 0.6*t",
"cp <= 0.3*t",
"ch <= 0.3*t",
"t  >  0",
"ch >  0",
"cp >  0",
"ct >  0"), normalize=TRUE)
E
@ 
\caption{Defining an {\tt editmatrix} from a {\tt character} vector containing verbose edit statements.
The option {\tt normalize=TRUE} ensures that all comparison operators are either ${\tt <}$, ${\tt \leq}$ or ${\tt ==}$.}
\label{emfromtext}
\end{Rcode}
%

As Figure \ref{emfromtext} shows, the {\tt editmatrix} object is shown on the console
as a matrix, as well as a set of textual edit rules. The {\tt editrules}
package is capable of coercing a set of R expressions to an {\tt editmatrix}
and {\em vice versa}. To coerce text to a matrix, the {\tt editmatrix} function
processes the R language parsetree of the textual R expressions as provided by
the R internal {\tt parse} function. To coerce the matrix representation to
textual representation, an R character string is derived from the matrix which
can be parsed to a language object.

In the example, the edits were automatically named {\tt e1}, {\tt e2}, $\ldots$, {\tt e9}. It is
possible to name and comment edits by reading them from a {\tt data.frame}. 

\begin{Rcode}[t]
<<keep.source=true>>=
# generate a csv text string
E.csv <- 
'name , edit       , description
"b1"  ,    t == ct + p    ,  "total balance"
"b2"  ,    ct == ch + cp  ,  "cost balance"
"s1"  ,    p <= 0.6*t     ,  "profit sanity"
"s2"  ,    cp <= 0.3*t    ,  "personell cost sanity"
"s3"  ,    ch <= 0.3*t    ,  "housing cost sanity"
"p1"  ,    t >0           ,  "turnover positivity"
"p2"  ,    ch > 0         ,  "housing cost positivity"
"p3"  ,    cp > 0         ,  "personel cost positivity"
"p4"  ,    ct > 0         ,  "total cost positivity"'
# read into a data.frame
E.df <- read.csv(textConnection(E.csv))
# transform to an editmatrix
editmatrix(E.df)
@
\caption{Declaring an editmatrix with a {\tt data.frame}. The input {\tt data.frame} is required to have three columns named
{\tt name},(edit name, stored as rowname of augmented matrix) {\tt edit} (textual representation of the edit rule) 
and {\tt description} (a comment stating the intent of the rule). All must be of type {\tt character}.}
\end{Rcode}
%

The ability to read edit sets from a {\tt data.frame} facilitates defining and
maintaining the rules outside of the R environment by storing them in a
user-filled database or textfile. Manipulating and combining edits, for example
through variable elimination methods will cause {\tt editrules} to drop or
change the names and drop the comments, as they become meaningless after
certain manipulations.

\subsection{Basic manipulations and edit checking}
Table \ref{simplemanipulations} shows simple manipulation functions available
for an {\tt editmatrix}. Basic manipulations include retrieval functions for
the augmented matrix, coefficient matrix, constant vector and operators of an
{\tt editmatrix}. There are functions to test for and transform to normality.
The function {\tt violatedEdits} expects an {\tt editmatrix} and a {\tt
data.frame} or a named numeric vector. It returns a {\tt logical} {\tt array}
where every row indicates which edits are violated ({\tt TRUE}) by records in
the {\tt data.frame}. Figure \ref{violatedEdits} demonstrates the result of
checking two records against the editrules defined in Eqs.\ \eqref{e1}--\eqref{e9}.
%
%
\begin{table}
\begin{threeparttable}
\caption{Simple manipulation functions for objects of class {\tt editmatrix}}
\label{simplemanipulations}
\begin{tabular}{ll}
\hline
function                      & description\\
\hline
{\tt getA(E)}                 & Get matrix $\bf A$\\
{\tt getb(E)}                 & Get constant vector $\bf b$\\
{\tt getAb(E)}                & Get augmented matrix $[{\bf A},{\bf b}]$\\
{\tt getOps(E)}               & Get comparison operators\\
{\tt E[i,]}                   & Select edit(s) \\
{\tt as.editmatrix(A,b,ops)}  & Create an {\tt editmatrix} from it's attributes\\
{\tt normalize(E)}            & Transform {\tt E} to normal form\\
{\tt isNormalized(E)}         & Check whether {\tt E} is in normal form\\
{\tt violatedEdits(E, x)}     & Check which edits are violated by ${\bf x}$\\
{\tt isObviouslyRedundant(E)} & Check for tautologies in rows of {\tt E}\\
{\tt isObviouslyUnfeasible(E)}   & Check for contradictions in rows of {\tt E}\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}
%
%
\begin{Rcode}
<<keep.source=true>>=
# define two records in a data.frame
dat <- data.frame(
  t = c(1000, 1200),
 ct = c(400,  200),
 ch = c(100,  350),
 cp = c(500,  575),
 p =  c(500,  652 ))
# check for violated edits
violatedEdits(E,dat)
@
\caption{Checking which edits are violated for every record in a {\tt data.frame}.
The first record violates {\tt e1} and {\tt e2}, the second record violates {\tt e1},{\tt e2}, and {\tt e4}.}
\label{violatedEdits}
\end{Rcode}
%
%
Indexing of edits with the {\tt [} operator is restricted to selection only. 
No assignment can be made to indexed {\tt editmatrix} objects. In stead, 
{\tt as.editmatrix} should be used.

\subsection{Obvious redundancy and infeasibility}
When manipulating linear edit sets by value substitution and/or variable
elimination, the edit set can become polluted with redundant edits or, when
variable values are substituted, become infeasible. The {\tt editrules} 
package has two methods available which check for easily detectable
redundancies or infeasibility. The fourier-motzkin elimination method
has auxilary built-in redundancy removal, which is described in Section
\ref{sfouriermotzkin}.

A system of inequalities $\bf Ax\leq b$ is called infeasible when there is no
real vecor $\bf x$ satisfying it. It is a consequence of Farkas' lemma
(\cite{farkas:1902}, but see \cite{schrijver:1998} and/or \cite{kuhn:1956}) on
feasibility of sytems of linear equalities, that  a system is infeasible if and
only if $0\leq -1$ can be derived by taking positive linear combinations of the
rows of the augmented matrix $[{\bf A},{\bf b}]$. The function {\tt
isObiouslyinfeasible} returns a {\tt logical} indicating whether such a
contradiction is present. Subsitution of values may also lead to equalities of
the form $0=1$, which also indicate that the system has become infeasible.
Being obviously infeasible is sufficient for an {\tt editmatrix} to be
infeasible, but not necessary. Algorithm \ref{isObviouslyInfeasible} gives the
pseudocode for reference purposes.
%
\begin{algorithm}
\caption{{\sc isObviouslyInfeasible($E$)}}
\label{isObviouslyInfeasible}
\begin{algorithmic}
\Require a normalized {\tt editmatrix} $E$
\For {${\bf a}\cdot {\bf x}\odot b\in E$}
 \If{$\bf a=0$}
  \If {$(\odot\in\{=\}\land b\not=0)\lor(\odot\in\{\leq,<\}\land b<0)$} 
    \State \Return {\sc true}
  \EndIf
 \EndIf
\EndFor
\State\Return {\sc false}
\Ensure \Comment{{\tt logical} indicating if $E$ is obviously infeasible.}
\end{algorithmic}
\end{algorithm}
%
\begin{algorithm}
\caption{{\sc isObviouslyRedundant($E$)}}
\label{isObviouslyRedundant}
\begin{algorithmic}
\Require a normalized {\tt editmatrix} $E$, with $m$ edits
\State  ${\bf v} \leftarrow$ ({\sc false})$^{\times{m}}$
\State $i\leftarrow 0$
\For {${\bf a}\cdot {\bf x}\odot b\in E$}
\State $i\leftarrow i+1$
 \If{$\bf a=0$}
  \If {$(\odot\in\{=\}\land b=0)\lor(\odot\in\{\leq,<\}\land b>0)$} 
    \State $v_i\leftarrow${\sc true}
  \EndIf
 \EndIf
\EndFor
\Ensure ${\bf v}$ \Comment{{\tt logical} vector indicating which rows of $E$ are obviously redundant.}
\end{algorithmic}
\end{algorithm}

When new edits are derived, either by value substitution or by variable elimination,
redundant rules of the form $0 \leq 1$ or $0=0$ can be generated. The function {\tt isObviouslyRedundant}
detects such rules and returns a {\tt logical} vector indicating which rows of an {\tt editmatrix}
are redundant. Pseudocode is given in Algorithm \ref{isObviouslyRedundant}.








\section{Manipulation of linear restrictions}
There are two fundamental operations possible on edit sets, both of which
(possibly) reduce the number of variables involved in the edit set. The first,
most simple one is when a value is substituted into an edit. The second
possibility is variable elimination. For a set of linear equalities, one can
apply Gaussian elimination, while for sets of inequalities or mixed sets of
equalities and inequalities Fourier-Motzkin elimination is applied. While
variable substitution and Gaussian elimination guarantee that the eliminated
variable is not involved in the derived edit set anymore, this is not
necessarily the case for Fourier-Motzkin elimination.



\subsection{Value substitution}
Given a set of $m$ linear edits as defined in Eq.\ \eqref{editset}. For
any record $\bf x$ it must hold that
\begin{equation}
{\bf Ax}\boldsymbol{\odot}  {\bf b},\quad \boldsymbol{\odot}\in\{<,\leq,=,\geq,>\}^m.
\label{subst}
\end{equation}
Substituting one of the unknowns $x_j$ by a certain value $x$ amounts to
replacing the $j^{\th}$ column of $\bf A$ with ${\bf 0}$ and ${\bf b}$ with
${\bf b}-{\bf a}_j'x$. After this, the reduced record of unknowns, with $x_j$
replaced by $x$ has to obey the adapted system \eqref{subst}. For reference
purposes, Algorithm \ref{replaceValue} spells out the substitution routine.
The function was named {\tt replaceValue} since {\tt substitute} is already
defined in the R-base. Figure \ref{RreplaceValue} shows how {\tt replaceValue}
can be called from the R environment.
%
%
\begin{algorithm}[t]
\caption{{\sc replaceValue}$(E,j,x)$}
\label{replaceValue}
\begin{algorithmic}
\Require $E=\langle [{\bf A}=[{\bf a}_1,{\bf a}_2,\ldots,{\bf a}_j ,\ldots, {\bf a}_n],{\bf b}],\boldsymbol{\odot}\rangle$, 
    $x\in\mathbb{R}$, $j\in \{1,2,\ldots n\}$
\Ensure $\left\langle\left[{\bf A}=[{\bf a}_1,{\bf a}_2,\ldots,{\bf a}_{j-1},{\bf 0},{\bf a}_{j+1},\ldots {\bf a}_n\right],
    {\bf b}-{\bf a}_jx],\boldsymbol{\odot}\right\rangle$
\end{algorithmic}
\end{algorithm}

\begin{Rcode}
<<>>=
replaceValue(E,"t",10)
@
\caption{Substituting the value 10 for the turnover variable using the {\tt replaceValue} function.}
\label{RreplaceValue}
\end{Rcode}


\subsection{Gaussian elimination}
The well-known Gaussian elimination routine has been implemented here as a utility function,
enabeling users to reduce the equality part of their edit matrices to reduced row echelon form.
The {\tt echelon} function has been overloaded to take either an R {\tt matrix} or an {\tt editmatrix}
as argument. In the latter case, the equalities are transformed to reduced row echelon form, while
inequalities are left untreated. 


\begin{Rcode}
\small
<<>>=
echelon(E)
@
\caption{The {\tt echelon} function transforms the linear equalities of an editmatrix to
reduced row echelon form. See Figure \ref{emfromtext} for the original definition of {\tt E}.}
\end{Rcode}


\subsection{Fourier-Motzkin elimination}
\label{sfouriermotzkin}

\section{Error localization for numerical data}

\subsection{The generalized Fellegi-Holt paradigm}

\subsection{General binary search with the {\tt choicepoint} algorithm}

\subsection{Error localization with {\tt cp.editmatrix}}

\section{Conclusions}

\newpage

\bibliographystyle{chicago}
\bibliography{editrules}


\end{document}
