%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical data edits and error localization with the {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 2.0 fo the package will have
the full vignette. At the moment, {\bf functionality for treating categorical data
has  beta status} so bugs are likely.


Refer to the accompanying paper
\cite{jonge:2011} for manipulation of linear edits.  }
\end{abstract}

\newpage
\tableofcontents
\listofalgorithms

\paragraph{Reading guide.} This paper contains a fair amount of background on
the algorithms and methods behind the {\sf editrules} package. Readers who want
to get started without going through the theory can read the following subsections:
1   $\rightarrow$ 
2.2 $\rightarrow$ 
2.3 $\rightarrow$
3.1 $\rightarrow$
3.4 $\rightarrow$
4.2. 

\newpage


\section{Introduction}
The value domain of categorical data records is usually limited by domain rules
interrelating these variables.  The simplest examples are cases where the value
of one variable excludes values of another variable. For example: if the age
class of a person is ``child'', then (by law) the marital status cannot be
``married''. In survey or administrative data, violations of such rules are
frequently encountered. Resolving such violations is an important step prior to 
data analysis and estimation.

A categorical data record $r$ with $n$ variables may be defined as an
element of the cartesian product space $D$:
\begin{equation}
D = D_1\times D_2\times\ldots\times D_n,
\label{eqDomain}
\end{equation}
where each $D_k$ is a finite set of $d_k$ possible categories for variable $k$ 
We label the categories as follows:
\begin{equation}
D_k = \{c\in D_k\,|\,c=1,2,\ldots,d_k\}.
\label{eqVariableDomain}
\end{equation}
%

Each restriction $e$ is a subset of $D$ and we say that that {\em if $r\in e$
then $r$ violates $e$}. Conversely, when $r\not\in e$ we say that $r$ {\em
satisfies} $e$. In data editing literature, such rules are referred to as {\em
edit rules} or {\em edits}, in short. In the context of contingency tables they
are referred to as {\em structural zeros} since each rule implies that one or
more cells in the $d_1\times d_2\times\ldots \times d_n$ contingency table must
be zero. A record is {\em  valid} if it satisfies every edit imposed on $D$.

Large, complex surveys may consist of hundreds of interrelated rules and
variables, which impedes resolution of edit violations and renders manual
manipulation infeasible. \citet{winkler:1999} mentions practical cases where
statistical offices handle 250, 300 or 750 categorical edit rules for surveys.


The {\sf R} package {\sf editrules}  offers functionality to define, manipulate
and maintain sets of edit rules with relative ease. It also implements error
localization functionality based on the generalized principle of
\citep{fellegi:1976}, which states that one should find the smallest (weighted)
number of variables whose values can be adapted such that all edits can be
satisfied. Fellegi and Holt's principle should be considered as the last resort
of data editing. It is useful in situations where a record violates one or more
edits and there is no information about the cause of the error. In certain
cases, the cause of error can be estimated with near certainty, for example in
the case of typing errors in numerical data.  We refer the reader to
\cite{scholtus:2008,scholtus:2009} and \cite{loo:2011} for such cases.

The purpose of this paper is to give a technical overview of the representation
and manipulation of edits in the {\sf editrules} package, as well as some coded
examples to get new users started.  




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Defining and checking categorical constraints}
In the next section we describe the representation of edits and records as
implemented in the {\sf editrules} package. Readers not interested in the
underlying principles may skip Section \ref{sectBoolrep}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boolean representation of records and edits}
\label{sectBoolrep}
Categorical records may be represented as  a vector of boolean values. A
boolean vector of dimension $d$ is an element of the boolean algebra 
\begin{equation}
\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
\end{equation}
where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
logical operators work elementwise on their operands. To facilitate the
discussion we will also allow the standard arithmetic operations addition and
subtraction on boolean vectors (this is also consistent with the way {\sf R}
handles vectors of class {\sf logical}). 

To represent a record $r=(r_1,r_2,\ldots,r_n)$, assign to every category
$c$ in $D_k$ a unique standard basisvector $\vec{\delta}_k(c)$ of
$\mathbb{B}^{d_k}$.  The boolean representation $\rho(r)$ of the full
record is the direct sum
%
\begin{equation}
    r \xrightarrow{\rho} \vec{\delta}_{1}(r_1)\oplus\vec{\delta}_{2}(r_2)\oplus\ldots\oplus\vec{\delta}_n(r_n),
\end{equation}
which we will write as
\begin{equation}
\rho(r) = {\bf v}_1 \oplus{\bf v}_2\oplus\cdots\oplus{\bf v}_n \equiv {\bf v}.
\end{equation}
The dimension $d$ of $\rho(r)$ is given by the total number of categories of all variables
\begin{equation}
d = \sum_{k=1}^n d_k.
\label{eqSumdk}
\end{equation}
When each record in a dataset is represented this way, summing the vectors
yields the $d$-dimensional vecorized representation of the $d_1\times
d_2\times\ldots\times d_n$ contingency table of the dataset. This is sometimes
called the complete disjunctive table. 

\begin{example}
\label{datamodel}
Consider the variables {\em marital status}, {\em age}, and {\em position in household} from
the domain $D=D_1\times D_2\times D_3$. We define
\begin{eqnarray}
D_1 &=& \{{\rm married},{\rm unmarried},{\rm widowed},{\rm divorced}\}\\
D_2 &=& \{{\rm under aged},{\rm adult}\}\\
D_3 &=& \{{\rm partner},{\rm child},{\rm other}\}.
\end{eqnarray}
The record $r=({\rm married},{\rm adult},{\rm partner})$ has boolean representation
\begin{equation}
\rho(r) = (1,0,0,0)\oplus(0,1)\oplus(1,0,0) = (1,0,0,0,0,1,1,0,0).
\end{equation}
\end{example}

An edit $e$ is a subset of $D$ which can be written as the cartesian product
\begin{equation}
    e = A_1\times A_2\ldots\times A_n\textrm{, where } A_{k}\subseteq D_k,\: k=1,2,\ldots n. 
    \label{eqDefEdit}
\end{equation}
The interpretation of an edit is that if a record ${\bf v}\in e$, then ${\bf
v}$ is considered invalid. The following properties follow immediately.
\begin{remark}
If $e\subset D$ and $e'\subset D$ are edits, then $e\cup e' = \{e,e'\}$ and 
$e\cap e'= A_1\cap A'_1\times A_2\cap A'_2\times\cdots\times A_n\cap A'_n$
are also edits.
\label{editremark}
\end{remark}
An edit, expressed as in Eq.\ \eqref{eqDefEdit} is said to be in {\rm
normal form}.  A variable $v_k$ is {\em involved} in an edit if $A_k\subset
D_k$.  Conversely, we say that $e$ {\em involves} $v_k$ if $v_k$ is involved in
$e$. A variable $v_k$ for which $A_k=D_k$ is not involved in $e$.  Since every
category $i$ of $D_k$ is mapped to a unique basis vector $\vec{\delta}_k(i)$,
edits have a boolean representation $\rho(e)$, given by
\begin{eqnarray}
    e &\xrightarrow{\rho}&
    \Lor_{i\in A_1}\vec{\delta}_1(i)\oplus
    \Lor_{i\in A_2}\vec{\delta}_2(i)\oplus\ldots
    \oplus\Lor_{i\in A_n}\vec{\delta}_n(i),
\end{eqnarray}
which may simply be written as
\begin{equation}
    \rho(e) = {\bf a}_1\oplus{\bf a}_2\oplus\ldots\oplus{\bf a}_n\equiv{\bf a}.
\label{EqRhoE}
\end{equation}

\begin{example}
Using the data model from Example \ref{datamodel}, the edit that says that under aged people
cannot be married has set representation
\begin{equation}
e = \{\textrm{\rm married}\}\times\{\textrm{\rm under aged}\}\times\{{\rm partner},{\rm child},{\rm other}\},
\end{equation}
which translates to the boolean representation
\begin{equation}
\rho(e) = (1,0,0,0)\oplus(0,1)\oplus(1,1,1) = (1,0,0,0,0,1,1,1,1).
\end{equation}
\end{example}
It is easy to check that an edit contains variable $k$  if and only if the
inner product ${\bf 1}_{d_k}\cdot{\bf a}_k<d_k$, where ${\bf 1}_{d_k}$ is a
$d_k$ vector of ones.

A record ${\bf v}$ violates an edit if $v_k\in A_k$, $k=1,2,\ldots n$.  In the
boolean representation this can be written as a condition on the standard inner
product between the boolean representation of a record and an edit:
\begin{equation}
\sum_{k=1}^n \vec{\delta}_k(v_k)\cdot{\bf a}_k =\rho({\bf v})\cdot{\bf a} =  n.
\label{eqViolatedEdits}
\end{equation}

Suppose that $E$ is a set of edits of the form \eqref{eqDefEdit}. It is not difficult to verify that an 
edit $e\in E$ is redundant if
%
\begin{eqnarray}
    \label{eqRedundancy1}
    A_k &=&\varnothing,\textrm{ for any } k\in1,2,\ldots,n\\
    \lefteqn{\textrm{or}}\nonumber\\
    \label{eqRedundancy2}
    e   &\subseteq& e'\textrm{ with  } e'\in E.
\end{eqnarray}
In \eqref{eqRedundancy1}, $e$ is redundant since it cannot contain any records.
It can be tested by checking if any ${\bf 1}_{d_k}\cdot{\bf a}_k=0$.  In the case
of \eqref{eqRedundancy2}, $e$ is redundant because any edit violating $e$ also
violates $e'$. Using $\rho(e)={\bf a}$ and $\rho(e')={\bf a}'$, this can be
tested by checking if ${\bf a}\land{\bf a}'={\bf a}$ or equivalently if ${\bf
a}\lor {\bf a}'={\bf a}'$.

In the {\sf editrules} the boolean representation is mainly used to store edits
and to manipulate them with methods like variable substitution and elimination.
Data records can be stored in {\sf data.frame} objects, as usual. 

\subsection{The {\sf editarray} object}
In the {\sf editrules} package, a set of categorical edits is represented as an {\sf editarray}
object. Formally, we denote an {\sf editarray} $E$ for $n$ categorical variables and $m$ edits as
(brackets indicate a combination of objects)  
\begin{equation}
    E = \langle {\bf A},{\bf ind}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k,
    \label{eqEditarray}
\end{equation}
Each row ${\bf a}$ of ${\bf A}$ contains the boolean representation of one edit, and the
$d_k$ denote the number of categories of each variable.  The object {\bf ind}
is a nested {\sf list} which relates columns of {\bf A} to variable names and
categories.  Labeling variables with $k\in1,2,\ldots,n$ and category values
with $c\in 1,2,\ldots,d_k$, we use the following notations:
\begin{eqnarray}
\label{eqInd1}
    {\bf ind}(k,c) &=& \sum_{l< k }d_l + c\\
    {\bf ind}(k)   &=& \{{\bf ind}(k,c)\,|\, c\in D_k\}.
\label{eqInd2}
\end{eqnarray}
So $\ind(k,c)$ is the column index in {\bf A} for variable $k$ and category $c$
and $\ind(k)$ is the set of column indices corresponding to the categories of
variable $k$.  The {\sf editarray} is the central object for computing with
catgegorical edits, just like the {\sf editmatrix} is the central object for
computations with linear edits.

It is both tedious and error prone to define and maintain an {\sf editarray} by hand.
In practice, categorical edits are usually stated verbosely, such as: ``a male
subject cannot be pregnant'', or ``an under-aged subject cannot be married''.
To facilitate the definition of edit arrays, {\sf editrules} is equipped with a
parser, which takes {\sf R}-statements in {\sf character} format, and translates them
to an {\sf editarray}.

%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
datamodel(E)
@
\caption{Defining a simple {\sf editarray} with the {\sf editarray} function.
The array is printed with abbreviated column heads, which themselves consist of
variable names and categories seperated by a colon (by default). When printed
to screen, a {\sf character} version of the edits is shown as well, for
readability.
}
\label{Reditarray}
\end{Rcode}
%
Figure \ref{Reditarray} shows a simple example of defining an editmatrix with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\sf editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) of multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. 

The function {\sf datamodel} accepts an edit array as input and returns an
overview of variables and their categories for easy inspection.
When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\sf <abbreviated var. name><separator><abbreviated cat. label>}, 
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\sf :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\sf sep} argument to {\sf editarray}.

Internally, {\sf editarray} uses the {\sf R} internal {\sf parse} function to
transform the {\sf character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\sf as.character} has
been overloaded to derive a {\sf character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

The character expressions that can be read by {\sf editarray}, such as
\begin{quote}
\verb+"if ( gender == 'male' ) pregnant = 'no'"+ 
\end{quote}
follows standard {\sf R} syntax, which should be already familliar to the
reader. Note that double quotes are used to enclose the whole string, while
single quotes are used for category names. Table \ref{tabOperators} shows
which operators and functions can be used to specify categorical edit rules.



Categories may be litaral characters, or booleans.  It is worth noting that
expressions on the right hand side of the {\sf \%in\%}  and {\sf ==} operators
are evaluated. One useful application of this is that the categories, or data
model can be defined outside of the edits:
%
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
editarray(c( "x %in% xval","y %in% yval","if ( x %in% c('a','b') ) !y "))
@
%
The above example also illustrates the use of boolean categories.



\begin{table}
\begin{threeparttable}
\caption{Functions and operators that may be used to define edits with {\sf editarray} }
\label{tabOperators}
\begin{tabular}{ll}
\hline
Operator & Description\\
\hline
{\sf \%in\%} & Set membership$^*$  \\
{\sf ==}     & Equality$^*$ \\
{\sf if( <condition> ) <expression> } & conditional statement\\
{\sf c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\sf character} or {\sf logical}\\
{\sf \&\&}, {\sf \&}    & logical {\sc and}\\
{\sf ||}, {\sf |}      & logical {\sc or}\\
{\sf !}       & logical {\sc not}\\
\hline
\end{tabular}
$^*${\small Right-hand side is evaluated.}
\end{threeparttable}
\end{table}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coercion, checking, redundancy and infeasibility}
Table \ref{tabBasicfunctions} lists basic functions of {\sf editarray} objects.
The {\sf datamodel} function retrieves the variables and categories in an edit
array, and returns them as a two-column {\sf data.frame}. With {\sf
as.data.frame} or {\sf as.character} one can coerce an editarray so that it can
be written to a file or database. Character coercion is used when edeits are
printed to the screen. Optionally, coercing the datamodel to character form can
be switched off. The result of {\sf as.data.frame} version contains columns
with edit names, a character representation of the edits and a column for
remarks.

The function {\sf violatedEdits} takes an {\sf editarray} and a {\sf
data.frame} as input and returns a logical matrix indicating which record
(rows) violate which edits (columns). It works by parsing the {\sf editarray}
to R-expressions and evaluating them within the {\sf data.frame} environment.
By default, the records are checked against the data model. This can be turned
off by providing the optional argument {\sf datamodel=FALSE}. 


\begin{table}
\begin{threeparttable}
\caption{Basic functions for objects of class {\sf editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\sf datamodel(E)}           & get datamodel \\
{\sf getVars(E)}             & get a list of variables\\
{\sf as.data.frame(E)}       & coerce edits to {\sf data.frame}\\
{\sf contains(E)}            & which edits contains which variable\\
{\sf as.character(E)}        & coerce edits to {\sf character} vector\\
{\sf violatedEdits(E,x)}     & check which edits are violated by {\sf x}\\
{\sf isObviouslyRedundant(E)}& find redundancies [Eq.\ \eqref{eqRedundancy1}], duplicates\\
{\sf duplicated(E)}          & find duplicate edits\\
{\sf isSubset(E)}            & find edits, subset of another edit [Eq.\ \eqref{eqRedundancy2}]\\
{\sf isObviouslyInfeasible(E)}& detect contradictions\\ 
{\sf substValue(E,var,value)} & substitute a value\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}


When manipulating edit sets, redundant edits of the form of Eq.\
\eqref{eqRedundancy1} may arise. Such redundancies can be detected in the
boolean representation with {\sf isObviouslyRedundant}. By default, this
function also checks for duplicate edits, but this may be turned off. The
function {\sf duplicated} is overloaded from the standard {\sf R} function and
the function {\sf isSubset} (pseudocode in Algorithm \ref{algIsSubset}) detects which edits are a subset or duplicate of
another one. In the actual {\sf R} implementation, the only explicit loop is a call to {\sf R}'s {\sf vapply} function.
The other loops are avoided using {\sf R}'s indexing  and vectorization properties.
%
\begin{algorithm}[t]
\caption{{\sc isSubset}$(E)$}
\label{algIsSubset}
\begin{algorithmic}[1]
\Require An editarray $E=\langle{\bf A},\ind\rangle$.
\State ${\bf s} \leftarrow (\false)^m$
\For {$({\bf a}^{(i)},{\bf a}^{(i')})\in \rows({\bf A})\times\rows({\bf A})$ }
  \If {${\bf a}^{(i)}\lor {\bf a}^{(i')}={\bf a}^{(i')} $}
    \State $s_i\leftarrow\true$
  \EndIf
\EndFor
\Ensure Boolean vector $\bf s$ indicating which edits represented by  {\bf A} are a subset of another edit. 
\end{algorithmic}
\end{algorithm}



Manipulations may also lead to edits of the form $e=D$, in which case every possible
record is invalid, and the editarray has become impossible to satisfy. The function
{\sf isObviouslyInfeasible} detects whether any such edits are present. They can be 
detected by checking if $\sum_{j=1}^d\rho(e)_j=d$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of categorical restrictions}
The basic operations on sets of categorical edits are value substitution and
variable elimination. The former amounts to adapting the datamodel underlying
the edit set while the latter amounts to deriving relations between variables
not involving the eliminated variable. 

In the next subsection we give an example of value subsitution with the {\sf
editrules} package, as well as some background. In subsection
\ref{sscategoryresolution} we describe an elimination method, which appears to
be new to the field of data editing. 
In subsection \ref{ssequivalence} it is
shown that the method yields results equivalent to Fellegi and Holt's
elimination method while running in polynomial in stead of exponential time.
Finally, in subsection \ref{sseliminateexample} we given an example of
eliminating variables with the {\sf editrules} package. Readers not interested in 
the technical background can skip subsections \ref{sscategoryresolution} and 
\ref{ssequivalence}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Value substitution}
If it is assumed that in a record, one of the variables takes a certain value,
that value may be substituted in the edit rules. In the boolean representation
this amounts to removing all edits which exclude that value, since the record
cannot violate those edits. Secondly, the columns related to the substituted variable,
but not to the substituted category are removed, thus adapting the datamodel to the
new assumption. Algorithm \ref{substValue} gives the pseudocode for reference purposes.
%
\begin{algorithm}[t]
\caption{{\sc substValue($E$,$k$,$v$)}}
\label{substValue}
\begin{algorithmic}[1]
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$ and a value $v$
    \State $i \leftarrow \ind(k,v)$
    \State ${\bf A}\leftarrow {\bf A}\backslash\{{\bf a}\in\rows({\bf A})\,|\,a_i=\false\}$\Comment{Remove rows not involving $v$ }
    \State ${\bf A} \leftarrow{\bf A}\backslash\{{\bf a}^t_j\in\columns({\bf A})\,|\, j\in\ind(k)\backslash i\}$\Comment{Remove categories $\not=v$}
    \State Update {\bf ind}
    \Ensure $\langle{\bf A},{\bf ind}\rangle$ with $v$ substituted for variable $k$.
\end{algorithmic}
\end{algorithm}
% 

In the {\sf editrules} package, value substitution is performed by the {\sf substValue} function,
which accepts variable and category names. In the following example the editmatrix defined in 
Figure \ref{Reditarray} is used.
<<echo=true>>=
substValue(E,"gender","female")
@
In this case, the variable ``gender'' is substituted by the value ``female''.
With the gender is fixed, the datamodel reduces to
$\{\textrm{male}\}\times\{\textrm{no},\textrm{yes}\}$ and the restriction ``if
male then pregnant = true'' becomes meaningless and is therefore removed.

The {\sf R} implementation of {\sf substValue} has an extra option, allowing to choose
if the datamodel is reduced or not, which by default is set to \true.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variable elimination by category resolution}
\label{sscategoryresolution}
Given two edits $e$ and $e'$, with boolean representations ${\bf a}$ and
${\bf a}'$ respectively.  We define the {\em resolution operator} $\res_k$ as:
\begin{eqnarray}
\lefteqn{
    {\bf a} \res_k {\bf a}' = {\bf a}_1\land{\bf a}'_1\oplus\ldots\oplus
    {\bf a}_{k-1}\land{\bf a}'_{k-1}}\nonumber\\
&\oplus&    {\bf a}_k\lor{\bf a}'_k\oplus
    {\bf a}_{k+1}\land{\bf a}'_{k+1}\oplus\ldots\oplus
    {\bf a}_n\land{\bf a}'_n
\label{eqResolutionOperator}
\end{eqnarray}
For two edit sets ${\bf A}$ and ${\bf A'}$, we also introduce the notation
\begin{equation}
{\bf A}\res_k{\bf A}' = \{{\bf a}\res_k{\bf a}'\,|\, ({\bf a},{\bf a}')\in\rows({\bf A})\times\rows({\bf A}')\}.
\end{equation}
%
Observe that the resolution operator has the following properties, relevant for record checking.
\begin{eqnarray}
   \rho({\bf v})\in {\bf a}\res_k{\bf a}' &\Rightarrow& \rho({\bf v})\in{\bf a} \lor \rho({\bf v})\in{\bf a}'\\
   \rho({\bf v})\in {\bf a} &\Rightarrow& \rho({\bf v})\in{\bf a}\res_k{\bf a}' \lor {\bf a}\res_k{\bf a}'=\varnothing
    \label{eqRedundant}
\end{eqnarray}
That is, if a record violates ${\bf a}\res_k{\bf a}'$, it does so because it
violates ${\bf a}$ and/or ${\bf a}'$. Therefore, ${\bf a}\res_k{\bf a}'$ is
also an edit in the sense that a record is invalid if it is falls in the
derived edit.When ${\bf a}_k={\bf a}'_k$, the resulting edit is
the intersection of the original edits, in which case the resulting edit is
redundant.  

The operator is called resolution operator since its action strongly resembles
a resolution operation from formal logic.  If ${\bf a}_k\lor {\bf
a}'_k=(\true)^{d_k}$, the operator ``resolves'' or eliminates the $k^{\rm th}$
variable and we are left with a relation between the other variables,
regardless of the value of variable $k$. The edit resulting from a resolution
operation on two explicitly defined edits is called an {\em implied edit}. 
If the resolution operation happens to eliminate one of the variables, it is
called an {\em essentially new implied edit}. These terms were introduced by
\citet{fellegi:1976} who first solved the problem of error localization for
categorical data. 

The resolution operator can be used to eliminate a variable $k$ from a set of
edits represented by ${\bf A}$ category by category as follows (Algorithm
\ref{eliminate}).  Suppose that $j$ is the column index of the first category
of $k$.  Collect all pairs of $({\bf a}^+,{\bf a}^-)$ obeying $a^+_j=\true$ and
$a^-_j=\false$.  If there are no edits of type ${\bf a}^+$, the variable cannot
be eliminated and the empty set is returned. Otherwise, copy all ${\bf a}^+$ to
a new set of edits and add every ${\bf a}^+\res_k{\bf a}^-$. By construction,
these new edits all have $a_j=\true$. Possibly, redundant edits have been
produced, and these may be removed. The procedure is iterated for every
category of $k$, adding a category for which each $a_j=\true$ at each
iteration.
%
%
\begin{algorithm}[t]
\caption{{\sc eliminate($E$,$k$)}}
\label{eliminate}
\begin{algorithmic}[1]
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$
    \For{$j\in \ind(k)$}
    \State ${\bf A}^+ = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc true}\}$
    \State ${\bf A}^- = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc false}\}$ 
    \If{${\bf A}^+=\varnothing$}
        \State ${\bf A}\leftarrow\varnothing$
        \State {\bf break}
    \EndIf
    \State ${\bf A}\leftarrow {\bf A}^+\cup {\bf A}^+\res_k {\bf A}^-$
    \State Delete rows which have $\textrm{\sc isSubset}(\langle{\bf A},\ind\rangle)=\true$.
    \EndFor
    \Ensure {\sf editarray} $\langle{\bf A},\ind\rangle$ with variable $k$ eliminated
\end{algorithmic}
\end{algorithm}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Equivalence to Fellegi and Holt's elimination method}
%\label{ssequivalence}
%In this subsection we prove that the function {\sc eliminate} of Algorithm 
%\ref{eliminate} is equivalent the elimination method of \cite{fellegi:1976}.
%Given a set of $m$ edits:
%\begin{equation}
%    E = \{ e^{(i)} \in \mathcal{P}(D)\,|\,
%    e^{(i)} \textrm{ as in Eq.\ \eqref{eqDefEdit}}
%    \textrm{, } 
%    i\in 1,2,\ldots,m\}
%\label{eqEditSet}
%\end{equation}
%where $\mathcal{P}(D)$ is the powerset of $D$.  \citet{fellegi:1976}, but also
%\cite{waal:2011} define a way to derive new edits, which may be written as a
%function $F_k$,
%\begin{eqnarray}
%\lefteqn{F_k(E) = 
%\ocap_{i=1}^m A^{(i)}_1\times
%\ocap_{i=1}^m A^{(i)}_2\times\ldots\times
%\ocap_{i=1}^m A^{(i)}_{k-1}\times 
%}\nonumber\\
%&\times& 
%\ocup_{i=1}^m A^{(i)}_k\times
%\ocap_{i=1}^m A^{(i)}_{k+1}\times
%\ldots\times
%\ocap_{i=1}^m A^{(i)}_m
%\label{eqFkSetRep}
%\end{eqnarray}
%where $k$ is called the {\em generating variable}. In the boolean representation, we have
%${\bf A}=\rho(E)$. Using the relations $\rho(e\cap e')=\rho({\bf e})\land\rho({\bf e})$
%and $\rho(e\cup e')=\rho(e)\lor\rho(e')$ we may write
%\begin{equation}
%F_k({\bf A}) = {\bf a}^{(1)}\res_k{\bf a}^{(2)}\res_k\cdots\res_k{\bf a}^{(m)},
%\quad {\bf a}^{(i)}=\rho\left(e^{(i)}\right),
%\label{eqFkBoolRep}
%\end{equation}
%where we used some obvious properties (symmetry, associativity) of the $\land$
%and $\lor$ operators as well. The following lemma and corrolary show that we can do
%all the work, necessary for implied edit derivation with the resolution operator. 
%%
%\begin{lemma}[\citet{fellegi:1976}]
%If $E$ is a set of edits, every edit, logically implied by $E$ can be derived by repeated application of Eq.\ \eqref{eqFkSetRep}
%on subsets of $E$.
%\end{lemma}
%\begin{proof}
%The proof is given in the reference and will not be repeated here.
%\end{proof}
%\begin{corollary}
%If $E$ is a set of edits, all implied edits can be derived by repeated
%application of the resolution operator on elements of the boolean
%representation of $E$.
%\label{corResolution}
%\end{corollary}
%\begin{proof}
%This follows from the equivalence between Eqs.\ \eqref{eqFkSetRep} and \eqref{eqFkBoolRep}.
%\end{proof}
%%
%Having established the use of the resolution operator, it becomes interesting
%to study its algebraic properties.  By substitution in the definition, it is
%easily shown that the resolution operator is symmetric, associative and
%idempotent. As a reminder, these properties are defined as follows.
%\begin{equation}
%\begin{array}{ll}
%\textrm{symmetry:}  &{\bf a}\res_k{\bf b} = {\bf b} \res_k {\bf a} \\
%\textrm{associativity:}& ({\bf a}\res_k{\bf b})\res_k {\bf c} = {\bf a}\res_k({\bf b}\res_k {\bf c}).\\
%\textrm{idempotency:} &{\bf a}\res_k {\bf a} = {\bf a}.
%\end{array}
%\end{equation}
%The resolution operator (although not called as such) was found earlyer and
%independently of the current authors by \cite{willenborg:1988}, who also
%discovered these properties.
%%
%The following property shows that the resolution operator leaves redundancy relations untouched.
%\begin{lemma}
%If ${\bf b}\subseteq {\bf c}$\textrm{, then }${\bf a}\res_k {\bf b}\subseteq {\bf a}\res_k {\bf c}$.
%\label{keepRedundancy}
%\end{lemma}
%\begin{proof}
%We may write ${\bf a} = {\bf a}_k\oplus{\bf a}'$ and similarly for {\bf b} and {\bf c}. This gives
%\begin{eqnarray*}
%{\bf a}\res_k {\bf b} &=& {\bf a}\res_k ({\bf b}\land {\bf c}) \\
%&=& {\bf a}_k\lor ({\bf b}_k\land {\bf c}_k) \oplus {\bf a}'\land ({\bf b}'\land{\bf c}')\\
%&=& ({\bf a}_k\lor{\bf b}_k)\land ({\bf a}_k\lor{\bf c}_k) \oplus ({\bf a}'\land {\bf b}')\land ({\bf a}'\land{\bf c}')\\
%&=& {\bf a}\res_k{\bf b}_k \land {\bf a}\res_k{\bf c} \subseteq {\bf a}\res_j{\bf c},
%\end{eqnarray*}
%and we are done.
%\end{proof}
%%
%This lemma is important because it shows that removing redundant edits (as shown in Algorithm \ref{eliminate}) 
%does not affect the outcome of {\sc eliminate} in the sense that the resulting edit set covers the same subset
%of $D$ with or without the redundancy removal step.
%
%We now define more formally the notion of variable elimination.
%\begin{definition}
%    Given a a function $f:\mathcal{P}(D)\to\mathcal{P}(D)$, and $E\in
%    \mathcal{P}(D)$. If none of the edits in $f(E)$ contain variable $k$, we say
%    that $f$ eliminates that variable from $E$.
%\end{definition}
%Remember that in the boolean representation, this means that ${\bf a}_k=(\true)^{d_k}$.
%The following theorem shows that every essentially new implied edit, generated by $k$ is found
%by Algorithm \ref{eliminate}.
%\begin{theorem}
%If $E$ is a set of edits. The function $\textrm{\sc eliminate}(E,k)$ generates
%every edit derived from $E$ from which variable $k$ has been eliminated. Moreover, these
%edits are mutually non-redundant.
%\label{eliminates}
%\end{theorem}
%\begin{proof}
%The fact that the resulting rows are mutually nonredundant follows from Lemma
%\ref{keepRedundancy}. Denote by ${\bf A}(j)$ the state of {\bf A} after $j$
%iterations. We have
%\begin{equation}
%{\bf A}(1) = {\bf A}^+\cup {\bf A}^+\res_k{\bf A}^-.
%\end{equation}
%Here ${\bf A}(1)$ contains every nonredundant derived edit with column ${\bf
%ind}(k,1)$ equal to \true.  For, if there is another derived edit, by corollary
%\ref{corResolution} it must be in ${\bf A}^+\res_k {\bf A}^+$, since
%${\bf A}^-\res_k {\bf A}^-$ only generates edits where $a_{\ind(k,1)}=\false$.
%Now, consider two edits ${\bf a}^{+}$ and ${\bf a}^{\prime +}\in{\bf
%A}^+$.  We have ${\bf a}^+\res_l{\bf a}^{\prime+}\subseteq {{\bf
%a}^+\cup {\bf a}^{\prime+}}\subseteq{\bf A}^+\subseteq{\bf A}(1)$ so
%each element of ${\bf A}^+\res_k{\bf A}^+$ is redundant (remember Remark \ref{editremark}). It follows from the
%definition of $\res_k$ that if ${\bf A}(j-1)$ contains every nonredundant edit
%with columns \mbox{$\ind(k,1),\ldots,\ind(k,j-1)$} equal to \true then
%${\bf A}(j)$ contains all nonredundant edits with columns
%$\ind(k,1),\ldots,\ind(k,j)$ equal to
%\true. Since the algorithm iterates over all $j\in\ind(k)$ the result follows.
%\end{proof}
%
%It is interesting to compare the procedure in Algorithm \ref{eliminate} with 
%Fellegi and Holt's procedure for generating implicit edits. This procedure,
%which is also described by \cite{waal:2011} may be summarized as follows.
%
%\vspace{1ex}
%\begin{algorithmic}[1]
%\Function{\textrm{\sc FH}}{$E$,$k$}
%%\Require A set of edits $E$ and a generating variable $k$.
%\State Find every $E_j\subseteq E$, with $j\in1,2,\ldots,s$ such that 
%\begin{itemize}
%\item $F_k(E_j)$ eliminates $k$.
%\item $E_j$ has a minimal number of elements $|E_j|$.
%\item The $E_j$ are mutually nonredundant in the sense $F_k(E_j)\not\subseteq F_k(E_l)$.
%\end{itemize}
%\State $E\leftarrow\cup_{j=1}^sF_k(E_j)$
%\State \Return $E$
%\EndFunction
%\end{algorithmic}
%\vspace{1ex}
%%
%Here, $E$ is a set of categorical edits in some form, and $k$ the variable to
%eliminate.  Most of the computational complexity is contained in line 2, where
%the search space is determined by the power set of $E$, yielding exponential
%complexity in the number of edits.
%
%The complexity of the {\sc eliminate} algorithm is determined by the 7th line
%in Algorithm \ref{eliminate}, which is quadratic in the current number of edits
%in the for-loop. This recurrence relation also yields exponential complexity in
%the number of edits. However, by removing the redundant edits at every
%iteration (a quadratic operation in itself), the actual number of edits can be
%kept to a minimum which reduces the complexity encountered in practice.
%
%
%By construction, the {\sc FH} function has the property that for two minimal,
%mutually nonredundant edit sets $E_j$ and $E_l$, such that $F_k(E_j)$ and $F_k(E_l)$
%eliminate $k$, we have
%\begin{equation}
%\textrm{\sc FH}(E_j\cup E_l,k)\simeq \textrm{\sc FH}(E_j,k)\cup\textrm{\sc FH}(E_l,k),
%\end{equation}
%where $\simeq$ indicates that the set of edits on the left hand side cover the same
%subset of $D$ as the edits on the right hand side.
%The following corollary establishes equivalence between the 
%procedure of Fellegi and Holt and the {\sc eliminate} algorithm.
%\begin{corollary}
%If $E_j$ and $E_l$ are minimal, mutually nonredundant edit sets such that 
%$F_k(E_j)$ and $F_k(E_l)$ eliminate $k$, then
%\begin{equation}
%\textrm{\sc eliminate}(E_j\cup E_l,k) \simeq \textrm{\sc eliminate}(E_j,k)\cup\textrm{\sc eliminate}(E_l,k).
%\end{equation}
%\end{corollary}
%\begin{proof}
%This follows immediately from Theorem \ref{eliminates}.
%\end{proof}

\subsection{An example with {\sf eliminate}}


\section{Error localization in categorical data}
\label{secErrLocCat}

\subsection{A Branch and bound algorithm}
\label{sBandB}
The editrules package implements an error localization algorithm, based on the
branch-and-bound algoritm of \cite{waal:2003a}. The algorithm has been
extensively described in \cite{waal:2003} and \cite{waal:2011}. The algorithm
is similar to the branch-and-bound algoritm used for error localization in
numerical data in the editrules package as described in \citet{jonge:2011},
except that the elimination and substitution subroutines are implemented for
categorical data.

In short, a binary tree is created with the full set of edits and an erroneous
record at the root node. Two child nodes are created. In the first child node
the first variable of the record is assumed correct, and it's values is
substituted in the edits. In the second child node the variable is assumed
incorrect and it is eliminated from the set of edits. The tree is continued
recursively untill choices are made for each variable. Branches are pruned when
they cannot lead to a solution, leaving a partial binary tree where each path
from root to leaf represents a solution to the error localization problem.
Computational complexity is reduced further by pruning branches leading to
higher-weight solutions then solutions found earlier.

Recall the datamodel of Example \ref{datamodel}, with variables {\em marital status},
{\em age} and {\em position in household}. We define the following two edits:

\begin{tabular}{ll}
\\
$e^{(1)}$ & under aged people cannot be married\\
$e^{(2)}$ & If you are not married you cannot be a partner\\
\\
\end{tabular}\\
%
As an example we treat the following record with the bracnch-and-bound algorithm to 
localize the errors:
\begin{equation}
r = ({\rm married},{\rm under\:aged},{\rm partner }).
\end{equation}
At the beginning of the algorithm, only the root node is filled. The situation may be 
represented as follows:\\
%%%%%%%%%%%%%
% T0: ROOT NODE
%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1&0&0&0&1&0&1&0&0\\
        \hline
        {\bf a}^{(1)}&1&0&0&0&1&0&1&1&1\\
        {\bf a}^{(2)}&0&1&1&1&1&1&1&0&0
    \end{array}
$
\end{tabular}\hfill  Root node, $w=0$,
\end{center}
%
where ${\bf v}=\rho(r)$, and ${\bf a}_1$ and ${\bf a}_2$ are the boolean
representations of $e_1$ and $e_2$ respectively.  The weight $w$ counts the
number of variables that are assumed to be incorrect, which at the root node is
zero. 


The tree is generated in depth-first fashion. In the first step, we substitute
$r_1$, yielding
%%%%%%%%%%%
% T0L
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1&0&1&0&0\\
        \hline
       {\bf a}^{(1)}&1 & & & &1&0&1&1&1\\
    \end{array}
$
\end{tabular}\hfill Substitute $v_1$, $w=0$.
\end{center}
Here, ${\bf a}_2$ is removed, since it has no meaning for {\bf v} anymore. The
positions for the categories unmarried, widowed and divorced are left empty
here to signify that the datamodel has a fixed marital status now. The dark
part of the tree on the left shows which nodes have been treated. Continuing
we find

%%%%%%%%%%%
% T0LL
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1& &1&0&0\\
        \hline
        {\bf a}^{(1)}&1 & & & &1 & &1&1&1\\
    \end{array}
$
\end{tabular}\hfill Substitute $v_2$, $w=0$.
\end{center}
At this point we have fixed the value for {\em marital status} and {\bf age}.
It can be seen from the value of ${\bf a}^{(1)}$ for {\em position in household} that
no matter what value is chosen for that field, the value ${\bf v}\cdot{\bf a}=3$. Which
shows that this path will never lead to a valid solution.
We therefore prune the tree here, go up one node and turn right. 
%%%%%%%%%%%
% T0LR
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        v &1& & & &\phantom{1}&\phantom{0}&1&0&0\\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Eliminate $v_2$, $w=1$.
\end{center}
Eliminating the {\em age} variables yields an empty edit set. We may continue down
and substitute the value for {\em position in household}.
\begin{center}
%%%%%%%%%%%
% T0LRL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1& & \\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Substitute $v_3$, $w=1$.
\end{center}
Which yields the first solution: only the {\rm age} variable needs to be
changed.  In search for more solutions, we move up the tree and try to eliminate
{\em age}. However, since eliminating age would increase the weight to 2 we will prune
the tree at this point. Moving up to the root node and eliminating {\em marital status}
gives
%%%%%%%%%%%
% T0R
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&0&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&0&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Eliminate $v_1$, $w=1$.
\end{center}
Here ${\bf a}^{(3)}={\bf a}^{(1)}\res_1{\bf a}^{(2)}$. It is interpreted as the rule
that under-aged people cannot be a partner in the household (no matter what the marital status is).
Creating the next child node by substituting {\em age}, we get
\begin{center}
%%%%%%%%%%%
% T0RL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&\phantom{0}&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1& 1 &\phantom{0}&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Substitute $v_2$, $w=1$.
\end{center}
Going down the tree and substituting {\em position in household} yields
\begin{center}
%%%%%%%%%%%
% T0RLL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Elr\Tlr\Elrl\Tlrl%\Elrr\Tlrr\XTlrr
    \Er\Tr\Erl\Trl\Erll\Trll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&&1&&\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&\phantom{0}&1&\phantom{0}&\phantom{0}\\
    \end{array}
$ 
\end{tabular}\hfill Substitute $v_3$, $w=1$.
\end{center}
However, whatever value we would choose for the {\rm marital status} variable, it would always result
in an erroneous record (since ${\bf a}^{(3)}$ has \true on all categories). Therefore, we go up one step in the
tree. Eliminating {\em age} would increase the weight to 2, but since we already found a solution
with weight equal to 1, this path need not be followed. We go up another node and bound on the fact
that eliminating {\em position in household} would yield the same problem. The final tree may be represented as follows:
\begin{center}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl\Erll\Trll\XTrll
%    \Elrr\Tlrr\XTlrr
%    \Err\Trr\XTrr 
%    \Erlr\Trlr\XTrlr
\end{picture}$\:$.
\end{center}
Here, every evaluated node is colored black, and a node is crossed when a bound
condition was encountered. The only (minimal) solution created is represented
by the path substitute {\em marital status} $\rightarrow$ eliminate {\em age}
$\rightarrow$ substitute {\em position in household}. This corresponds to the
solution where age has to be altered to fix the record, and indeed changing age
from {\em under aged} to {\em adult} will make the full record valid. Note that
the branch-and-bound algorithm reduced the number of nodes to be evaluated from
$15$ to $8$ in this case.



\subsection{Error localization with {\sf localizeErrors}}
The function {\sf localizeErrors} applies the branch-and-bound algorithm to
determine the minimal weight error location for every record in a {\sf
data.frame}. The columns may be in {\sf character} or {\sf factor} format.  The
function has an identical interface for numerical data under linear edits and
categorical  data under categorical edits. It is implemented as an {\sf S3}
generic function, accepting eiter an {\sf editmatrix} or an {\sf editarray} as
the first argument and a {\sf data.frame} as the second argument. Funrther
arguments are a vector of variable weights, a maximum search time (in seconds)
to spend on a single record, a maximum weight and the maximum number of
variables which may be changed. The latter two arguments introduce extra bound
conditions in the branch-and-bound algorithm.

Even when variables are weighted, the solution to the error localization
problem may not be unique. In those cases {\sf localizeErrors} will draw
uniformly from the set of lowest-weight solutions. The degeneracy (number of
equivalent solutions found) is reported in the output.

The result of a call to {\sf localizeErrors} is an object of class {\sf errorLocalization}.
It contains a boolean matrix with error locations for each record as well as a status 
report containging degeneracies, solution weights runtimes and wether the maximum runtime
was exceeded. It also contains a timestamp (in the form of a {\sf Date} object) and the
name of the user running {\sf R}. Table \ref{tblErrorLocation} gives an overview of
the slots involved.
%
\input{tex/errorLocation.tex}

In Figure \ref{RlocalizeErrors} an example of the use of {\sf localizeErrors} is
given. The data model and rules are as in subsection \ref{sBandB}. The records
are given by
<<keep.source=false,echo=false>>=
(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under aged','adult','adult' ),
    positionInHousehold=c('child','other','marriage partner')
))
@
The edits state that under aged cannot be married and that you cannot be a
marriage partner if you're not married. Clearly, the first and third record
disobay some rules of these rules while the second record is valid. The first
record can be repaired by adapting age and the second record can be made
consistent by changing either {\em positin in household} or {\em marital
status}. In the latter case, both solutions have equal weight and {\sf
localizeErrors} has drawn one solution.




\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under aged','adult')",
    "maritalStatus %in% c('unmarried','married','widowed','divorced')",
    "positionInHousehold %in% c('marriage partner', 'child', 'other')",
    "if( age == 'under aged' ) maritalStatus == 'unmarried'",
    "if( maritalStatus != 'married' )
        !positionInHousehold %in% c('marriage partner','child')"
    )
)

(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under aged','adult','adult' ),
    positionInHousehold=c('child','other','marriage partner')
))

set.seed(1)
localizeErrors(E,dat)
@
\caption{Localizing errors in a {\sf data.frame} of records. The data model is as defined in Example \ref{datamodel}.
The randseed is set before calling {\sf localizeErrors} to make results reproducible. The tird record has degeneracy 2, which means that the chosen solution was
drawn uniformly from two equivalent solutions with weight 1.}
\label{RlocalizeErrors}
\end{Rcode}


\subsection{Error localization with {\sf errorLocalizer}}

\section{Conclusions}
\clearpage
\bibliographystyle{chicago}
\bibliography{editrules}

\clearpage

\appendix
\section{Notation}
\begin{table}[h]
\begin{tabular}{lp{0.8\textwidth}}
\hline
Symbol          & Explanation and reference\\
\hline
${\bf a}$       & An edit, in boolean representation: ${\bf a}=\rho(e)$, Eq.\ \eqref{EqRhoE}.\\
${\bf a}_k$     & Boolean representation of one variable in {$\bf a$}. ${\bf a}=\oplus_{k=1}^n{\bf a}_k$.\\
${\bf A}$       & Set of edits, in $m\times d$ boolean representation.\\
$c$             & Label for a single category of $D_k$. \\
$D$             & Set (domain) of all possible categorical records, Eq.\ \eqref{eqDomain}.\\
$D_k$           & Set of possible categories for variable $k$. Eq.\ \eqref{eqVariableDomain}.\\
$d$             & Number of categories (in total), Eq.\ \eqref{eqSumdk}.\\
$d_k$           & Number of categories in $D_k$.\\ 
$e$             & An edit, in set representation: $e\subseteq D$, [Eq.\ \eqref{eqDefEdit}].\\
$E$             & An editarray, Eq.\ \eqref{eqEditarray}, or a set of edits in set representation.\\
$\ind$          & Function relating categories $c$ of variable $k$ to columns in {\bf A}, Eqs.\eqref{eqInd1} and \eqref{eqInd2}.\\
$i$             & row index in {\bf A} (labeling edits).\\
$j$             & column index in {\bf A} (labeling categories).\\
$m$             & Number of edits.\\
$n$             & Number of variables.\\
$r$             & Categorical record, in set representation: $r\in D$.\\
$\res_k$        & Resolution operator Eq.\ \eqref{eqResolutionOperator}.\\
$\rho$          & Map, sending set representation to boolean representation. \\
${\bf v}$       & Categorical record, in boolean representation: ${\bf v} = \rho(r)$.\\
${\bf v}_k$     & Boolean representation of a single variable ${\bf v}=\oplus_{k=1}^n{\bf v}_k$.\\
\hline
\end{tabular}
\end{table}

\end{document}


%The following distributive property also holds
%\begin{equation}
%\begin{array}{ll}
%\textrm{distributivity:}& ({\bf a}\res_i{\bf b})\res_j{\bf c} = ({\bf a}\res_j{\bf c})\res_i({\bf b}\res_j{\bf c}).
%\end{array}
%\end{equation}

