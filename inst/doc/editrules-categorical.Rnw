%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }


\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical data edits and error localization with the {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is nearly finished. Version 2.0 fo the package will have
the full vignette. At the moment, {\bf functionality for treating categorical data
has  beta status} so bugs are likely.
}

This paper is the second paper describing functionalities of the {\sf R} {\sf
editrules} package.  The first paper \citep{jonge:2011} describes methods and
implementation for handling numerical data while this paper is concerned with handling
purely categorical data. The {\sf editrules} package is designed to offer a
user-friendly interface for edit definition, manipulation, and error
localization based on the generalized paradigm of Fellegi and Holt for users of
the {\sf R} language.  By providing  basic manipulations, such as are error
checking, feasibility tests, variable elimination, value substitution, and
redundancy checks, this package offers a tool set which may be used to
investigate and maintain large sets of categorical or numerical edit sets.
Finally, we note that the variable elimination method described in this paper
appears to be new in the field of data editing.
\end{abstract}

\newpage
\tableofcontents
\listofalgorithms

\paragraph{Reading guide.} This paper contains a fair amount of background on
the algorithms and methods behind the {\sf editrules} package. Readers who want
to get started without going through the theory can read subsections
\ref{sIntroduction}   $\rightarrow$ 
\ref{sseditarray} $\rightarrow$
\ref{sscommonfunctions} $\rightarrow$
\ref{ssvaluesubstitution} $\rightarrow$ 
\ref{sseliminateexample} $\rightarrow$
\ref{sslocalizeerrors} $\rightarrow$
\ref{sserrorlocalizer} 

\newpage


\section{Introduction}
\label{sIntroduction}
The value domain of categorical data records is usually limited by rules
interrelating these variables.  The simplest examples are cases where the value
of one variable excludes values of another variable. For example: if the age
class of a person is ``child'', then (by law) the marital status cannot be
``married''. In survey or administrative data, violations of such rules are
frequently encountered. Resolving such violations is an important step prior to 
data analysis and estimation.

A categorical data record $v$ with $n$ variables may be defined as an
element of the Cartesian product space $D$ (for domain):\index{record!value domain}
\begin{equation}
D = D_1\times D_2\times\cdots\times D_n,
\label{eqDomain}
\end{equation}
where each $D_k$ is a finite set of $d_k$ possible categories for variable $k$.
We label the categories as follows:
\begin{equation}
D_k = \{v_k\in D_k\,|\,v_k=1,2,\ldots,d_k\}.
\label{eqVariableDomain}
\end{equation}
%

Each restriction $e$ is a subset of $D$ and we say that that {\em if $v\in e$
then $v$ violates $e$}. \index{violates}. Conversely, when $r\not\in e$ we say
that $v$ {\em satisfies} $e$.\index{satisfies} In data editing literature, such
rules are referred to as {\em edit rules} or {\em edits},\index{edit} in short.
In the context of contingency tables they are referred to as {\em structural
zeros} since each rule implies that one or more cells in the $d_1\times
d_2\times\cdots \times d_n$ contingency table must be zero. A record is {\em
valid} if it satisfies every edit imposed on $D$.

Large, complex surveys may consist of hundreds of interrelated rules and
variables, which impedes resolution of edit violations and renders manual
manipulation infeasible. \citet{winkler:1999} mentions practical cases where
statistical offices handle 250, 300 or 750 categorical edit rules for surveys.

The {\sf R} package {\sf editrules}  offers functionality to define, manipulate
and maintain sets of edit rules with relative ease. It also implements error
localization functionality based on the generalized principle of
\cite{fellegi:1976}, which states that one should find the smallest (weighted)
number of variables whose values can be adapted such that all edits can be
satisfied. Fellegi and Holt's principle should be considered as the last resort
of data editing. It is useful in situations where a record violates one or more
edits and there is no information about the cause of the error. In certain
cases, the cause of error can be estimated with near certainty, for example in
the case of typing errors in numerical data.  We refer the reader to
\cite{scholtus:2008,scholtus:2009} and \cite{loo:2011} for such cases.

The purpose of this paper is to give a technical overview of the representation
and manipulation of edits in the {\sf editrules} package, as well as some coded
examples to get new users started.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Defining and checking categorical constraints}
In the this section we describe the representation of edits and records as
implemented in the {\sf editrules} package. Subsection \ref{ssboolrep} describes
the background while subsection \ref{sseditarray} describes implementation
and gives coded examples.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boolean representation of records and edits}
\label{ssboolrep}
Categorical records may be represented as  a vector of boolean values. A
boolean vector of dimension $d$ is an element of the boolean algebra 
\index{boolean algebra}
\begin{equation}
\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
\end{equation}
where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
logical operators work element-wise on their operands. To facilitate the
discussion we will also allow the standard arithmetic operations addition and
subtraction on boolean vectors (this is also consistent with the way {\sf R}
handles vectors of class {\sf logical}). 

To represent a record $v=(v_1,v_2,\ldots,v_n)$, we assign to every category
$v_k$ in $D_k$ a unique standard basis vector $\vec{\delta}_k(v_k)$ of
$\mathbb{B}^{d_k}$.  The boolean representation $\rho(v)$ of the full
record is the direct sum
%
\begin{equation}
    v \xrightarrow{\rho} \vec{\delta}_{1}(v_1)\oplus\vec{\delta}_{2}(v_2)\oplus\cdots\oplus\vec{\delta}_n(v_n),
\end{equation}
which we will write as \index{record!boolean representation} the direct vector sum
\begin{equation}
\rho(v) = {\bf v}_1 \oplus{\bf v}_2\oplus\cdots\oplus{\bf v}_n \equiv {\bf v}.
\end{equation}
The dimension $d$ of $\rho(v)$ is given by the total number of categories of all variables
\begin{equation}
d = \sum_{k=1}^n d_k.
\label{eqSumdk}
\end{equation}
When each record in a dataset is represented this way, summing the vectors
yields the $d$-dimensional vectorized representation of the $d_1\times
d_2\times\cdots\times d_n$ contingency table of the dataset. This is sometimes
called the complete disjunctive table. 

\begin{example}
\label{datamodel}
Consider the variables {marital status}, {age}, and {position in household} from
the domain $D=D_1\times D_2\times D_3$. We define
\begin{eqnarray}
D_1 &=& \{{\sf married},{\sf unmarried},{\sf widowed},{\sf divorced}\}\\
D_2 &=& \{\textrm{\sf under-aged},{\sf adult}\}\\
D_3 &=& \{{\sf partner},{\sf child},{\sf other}\}.
\end{eqnarray}
The record $r=({\sf married},{\sf adult},{\sf partner})$ has boolean representation
\begin{equation}
\rho(r) = (1,0,0,0)_1\oplus(0,1)_2\oplus(1,0,0)_3 = (1,0,0,0,0,1,1,0,0).
\end{equation}
\end{example}

An edit $e$ is a subset of $D$ which can be written as the Cartesian product \index{edit}
\begin{equation}
    e = A_1\times A_2\cdots\times A_n\textrm{, where } A_{k}\subseteq D_k,\: k=1,2,\cdots n. 
    \label{eqDefEdit}
\end{equation}
\index{edit!normal form}
The interpretation of an edit is that if a record $v\in e$, then $v$ is
considered invalid. The following properties follow immediately.
\begin{remark}
If $e\subset D$ and $e'\subset D$ are edits, then $e\cup e' = \{e,e'\}$ and 
$e\cap e'= A_1\cap A'_1\times A_2\cap A'_2\times\cdots\times A_n\cap A'_n$
are also edits. \theend
\label{editremark}
\end{remark}
An edit, expressed as in Eq.\ \eqref{eqDefEdit} is said to be in {\rm normal
form}.  A variable $k$ is {\em involved} in an edit if $A_k\subset D_k$.
Conversely, we say that $e$ {\em involves} $k$ if $k$ is involved in $e$. A
variable $k$ for which $A_k=D_k$ is not involved in $e$.  Since every
category $v_k$ is mapped to a unique basis vector $\vec{\delta}_k(v_k)$,
edits have a boolean representation $\rho(e)$, given by
\begin{eqnarray}
    e &\xrightarrow{\rho}&
    \Lor_{v_1\in A_1}\vec{\delta}_1(v_1)\oplus
    \Lor_{v_2\in A_2}\vec{\delta}_2(v_2)\oplus\cdots
    \oplus\Lor_{v_n\in A_n}\vec{\delta}_n(v_n),
\end{eqnarray}
which may simply be written as\index{edit!boolean representation}
\begin{equation}
    \rho(e) = {\bf a}_1\oplus{\bf a}_2\oplus\cdots\oplus{\bf a}_n\equiv{\bf a}.
\label{EqRhoE}
\end{equation}

\begin{example}
Using the data model from Example \ref{datamodel}, the edit that says that under-aged people
cannot be married has set representation
\begin{equation}
e = \{\textrm{\rm married}\}_1\times\{\textrm{\rm under-aged}\}_2\times\{{\rm partner},{\rm child},{\rm other}\}_3
\end{equation}
which translates to the boolean representation
\begin{equation}
\rho(e) = (1,0,0,0)_1\oplus(0,1)_2\oplus(1,1,1)_3 = (1,0,0,0,0,1,1,1,1).
\end{equation}
\end{example}
In the boolean representation some properties can be checked by simple
calculations. For example, an edit involves variable $k$  if and only if the
inner product ${\bf 1}_{d_k}\cdot{\bf a}_k<d_k$, where ${\bf 1}_{d_k}$ is a
$d_k$ vector of ones.

A record ${v}$ violates an edit if every $v_k\in A_k$.  In the
boolean representation this can be written as a condition on the standard inner
product between the boolean representation of a record and an edit:
\begin{equation}
\sum_{k=1}^n \vec{\delta}_k(v_k)\cdot{\bf a}_k ={\bf v}\cdot{\bf a} =  n.
\label{eqViolatedEdits}
\end{equation}
Suppose that $E$ is a set of edits of the form \eqref{eqDefEdit}. It is not difficult to verify that an 
edit $e\in E$ is redundant if \index{edit!redundancy}
%
\begin{eqnarray}
    \label{eqRedundancy1}
    A_k &=&\varnothing,\textrm{ for any } k\in1,2,\ldots,n\\
    \lefteqn{\textrm{or}}\nonumber\\
    \label{eqRedundancy2}
    e   &\subseteq& e'\textrm{ with  } e'\in E.
\end{eqnarray}
In \eqref{eqRedundancy1}, $e$ is redundant since it cannot contain any records.
It can be tested by checking if any ${\bf 1}_{d_k}\cdot{\bf a}_k=0$.  In the case
of \eqref{eqRedundancy2}, $e$ is redundant because any edit violating $e$ also
violates $e'$. Using $\rho(e)={\bf a}$ and $\rho(e')={\bf a}'$, this can be
tested by checking if ${\bf a}\land{\bf a}'={\bf a}$ or equivalently if ${\bf
a}\lor {\bf a}'={\bf a}'$.
%
%
\begin{remark}
The boolean representation of records and edits is invertible. For convenience we
use the symbols $\in$, $\subset$ and $\subseteq$ for edits and record in set as wel as in 
boolean representation. For example, in stead of writing ${\bf v}\cdot {\bf a}=n$ we write 
${\bf v}\in {\bf a}$ (which is equivalent to $v\in e$) when convenient.
\label{remboolnotation}
\theend
\end{remark}
In the {\sf editrules} the boolean representation is mainly used to store edits
and to manipulate them through variable substitution and elimination.
Data records can be stored in {\sf data.frame} objects, as usual. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The {\sf editarray} object}
\label{sseditarray}
\index{editarray@{\sf editarray}}
In the {\sf editrules} package, a set of categorical edits is represented as an {\sf editarray}
object. Formally, we denote an {\sf editarray} $E$ for $n$ categorical variables and $m$ edits as
(brackets indicate a combination of objects)  
\begin{equation}
    E = \langle {\bf A},{\bf ind}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k,
    \label{eqEditarray}
\end{equation}
Each row ${\bf a}$ of ${\bf A}$ contains the boolean representation of one edit, and the
$d_k$ denote the number of categories of each variable.  The object {\bf ind}
is a nested {\sf list} which relates columns of {\bf A} to variable names and
categories.  Labeling variables with $k\in1,2,\ldots,n$ and category values
with $v_k\in 1,2,\ldots,d_k$, we use the following notations:
\begin{eqnarray}
\label{eqInd1}
    {\bf ind}(k,v_k) &=& \sum_{l< k }d_l + v_k\\
    {\bf ind}(k)   &=& \{{\bf ind}(k,v_k)\,|\, v_k\in D_k\}.
\label{eqInd2}
\end{eqnarray}
So $\ind(k,v_k)$ is the column index in {\bf A} for variable $k$ and category $v_k$
and $\ind(k)$ is the set of column indices corresponding to all categories of
variable $k$.  The {\sf editarray} is the central object for computing with
categorical edits, just like the {\sf editmatrix} is the central object for
computations with linear edits.

It is both tedious and error prone to define and maintain an {\sf editarray} by hand.
In practice, categorical edits are usually stated verbosely, such as: ``a male
subject cannot be pregnant'', or ``an under-aged subject cannot be married''.
To facilitate the definition of edit arrays, {\sf editrules} is equipped with a
parser, which takes {\sf R}-statements in {\sf character} format, and translates them
to an {\sf editarray}.

%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
datamodel(E)
@
\caption{Defining a simple {\sf editarray} with the {\sf editarray} function.
The array is printed with abbreviated column heads, which themselves consist of
variable names and categories separated by a colon (by default). When printed
to screen, a {\sf character} version of the edits is shown as well, for
readability.
}
\label{Reditarray}
\end{Rcode}
%
Figure \ref{Reditarray} shows a simple example of defining an {\sf editarray} with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\sf editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) of multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. 

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\sf <abbreviated var. name><separator><abbreviated cat. label>}
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\sf :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\sf sep} argument to {\sf editarray}.
For convenience, the function {\sf datamodel} accepts an {\sf editarray} as
input and returns an overview of variables and their categories for easy
inspection in the form of a {\sf data.frame}.

Internally, {\sf editarray} uses the {\sf R} internal {\sf parse} function to
transform the {\sf character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\sf as.character} has
been overloaded to derive a {\sf character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

Univariate edits define the domain of a variable. The domains form together a data model. A domain can be defined with common {\sf R}
syntax using the ${\sf \%in\%}$ operator. If a domain is defined explicitly,
it must follow the following syntax diagram.
\begin{syntdiag}
    "\""
    <name> "\%in\%"
    \begin{stack}
        "c("\begin{rep}\syncat\\","\end{rep}")"\\
        <identifier>\\
        "c(TRUE, FALSE)"
    \end{stack}
    "\""
\end{syntdiag}
Here, $\langle name\rangle$ is the name of a categorical variable, and $\langle
category\rangle$ is a literal category name. Note that the category name is
enclosed by single quotes while the entire statement is between double quotes.
That is, the entire statement has to be offered in string format to {\sf
editarray}. The $\langle identifier\rangle$ is the name of a predefined {\sf
character} variable storing the unique categories for a variable. In principle,
$\langle identifier\rangle$ may be replaced by any valid {\sf R} symbol
evaluating to a {\sf character} or {\sf factor} vector. However, such constructions are not
recommended, since multivariate edit rules depend on a fixed datamodel.

The multivariate rules can be defined in three ways. The most useful and common
way to define edits follows the following syntax diagram.

\begin{syntdiag}
    "\"if ("\begin{rep}
          <set expression>\\
          \begin{stack}"\&\&"\\ "\&"\end{stack}
       \end{rep}
        ")"
        \begin{rep}
          <set expression>\\
          \begin{stack}"||"\\ "|"\end{stack}
        \end{rep} "\""
\end{syntdiag}

Where each $\langle$ \textit{set expression}  $\rangle$ is a logical statement, following

\begin{syntdiag}
    \begin{stack}
        \\"!"
    \end{stack}
        <name>
        \begin{stack}
            \\
            \begin{stack} "=="\\ "!="\end{stack} 
                \begin{stack} \syncat \\ \begin{stack}\true\\ \false\end{stack}\end{stack}\\
                    "\%in\%"
                    \begin{stack} 
                        "c(" \begin{rep}\syncat\\ "," \end{rep} ")"\\
                        <identifier>\\
                        \begin{stack} \true\\ \false\end{stack}
                    \end{stack}
        \end{stack}
\end{syntdiag}

The reader can check that the examples given in Figure \ref{Reditarray} follow this syntax.
The example below illustrates the use of separately defined data models and boolean
categories.
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
( M <- editarray(c( 
    "x %in% xval",
    "y %in% yval",
    "if ( x %in% c('a','b') ) !y "
    )) )
@
%
The second way to define multivariate edits is based on rewriting on the basic classical
logic law $P\Rightarrow Q = \lnot P\lor Q$. It involves the following syntax diagram.
\begin{syntdiag}
        "\""
        \begin{rep}
          <set expression>\\
          \begin{stack}"||"\\ "|"\end{stack}
        \end{rep} "\""
\end{syntdiag}
Where each $\langle setexpression\rangle$ is as in the syntax diagram above.  In
practice, a user will commonly not use this form since it is less readable.
However, the {\sf as.character} method for {\sf editarray} can generate such
statements by passing the argument {\sf useIf=FALSE}, as shown below.
<<>>=
as.character(M,useIf=FALSE)
@
The main advantage of this form is that
contrary to the  {\sf if()} form, it allows for vectorized checking of edits,
which is why it is used internally.
%


%\begin{table}
%\begin{threeparttable}
%\caption{Functions and operators that may be used to define edits with {\sf editarray} }
%\label{tabOperators}
%\begin{tabular}{ll}
%\hline
%Operator & Description\\
%\hline
%{\sf \%in\%} & Set membership$^*$  \\
%{\sf ==}     & Equality$^*$ \\
%{\sf if( <expression> ) <expression> } & conditional statement\\
%{\sf c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\sf character} or {\sf logical}\\
%{\sf \&\&}, {\sf \&}    & logical {\sc and}\\
%{\sf ||}, {\sf |}      & logical {\sc or}\\
%{\sf !}       & logical {\sc not}\\
%{\sf ()}      & brackets\\
%\hline
%\end{tabular}
%$^*${\small Right-hand side is evaluated.}
%\end{threeparttable}
%\end{table}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coercion, checking, redundancy and feasibility}
\label{sscommonfunctions}
Table \ref{tabBasicfunctions} lists basic functions of {\sf editarray} objects.
The {\sf datamodel} function extracts the variables and categories from an {\sf
editarray}, and returns them as a two-column {\sf data.frame}. With {\sf
as.data.frame} or {\sf as.character} one can coerce an editarray so that it can
be written to a file or database. Character coercion is used when edits are
printed to the screen. Optionally, coercing the datamodel to character form can
be switched off. The result of {\sf as.data.frame} has columns with edit names,
a character representation of the edits and a column for remarks.

The function {\sf violatedEdits} takes an {\sf editarray} and a {\sf
data.frame} as input and returns a logical matrix indicating which record
(rows) violate which edits (columns). It works by parsing the {\sf editarray}
to R-expressions and evaluating them within the {\sf data.frame} environment.
By default, the records are checked against the data model. This can be turned
off by providing the optional argument {\sf datamodel=FALSE}. 

\index{editarray@{\sf editarray}!functions}
\begin{table}
\begin{threeparttable}
\caption{Functions for objects of class {\sf editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\sf datamodel(E)}            & get datamodel \\
{\sf getVars(E)}              & get a list of variables\\
{\sf as.data.frame(E)}        & coerce edits to {\sf data.frame}\\
{\sf contains(E)}             & which edits contains which variable\\
{\sf as.character(E)}         & coerce edits to {\sf character} vector\\
{\sf blocks(E)}               & Get list of independent blocks of edits\\
{\sf reduce(E)}               & Remove empty unnecessary variables and rows\\
{\sf isObviouslyRedundant(E)} & find redundancies [Eq.\ \eqref{eqRedundancy1}], duplicates\\
{\sf duplicated(E)}           & find duplicate edits\\
{\sf isSubset(E)}             & find edits, subset of another edit [Eq.\ \eqref{eqRedundancy2}]\\
{\sf isObviouslyInfeasible(E)}& detect simple contradictions\\ 
{\sf isFeasible(E)}           & detect if at least 1 valid record exists\\
{\sf substValue(E,var,value)} & substitute a value\\
{\sf eliminate(E,var)}        & eliminate a variable (sect.\ \ref{sseliminateexample})\\
{\sf violatedEdits(E,dat)}    & check which edits are violated by {\sf x}\\
{\sf localizeErrors(E,dat)}   & localize errors (sect.\ \ref{sslocalizeerrors})\\
{\sf errorLocalizer(E,x)}     & {\sf backtracker} for error localization (sect.\ \ref{sserrorlocalizer})\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}

When manipulating edit sets, redundant edits of the form of Eq.\
\eqref{eqRedundancy1} may arise. Such redundancies can be detected in the
boolean representation with {\sf isObviouslyRedundant}. By default, this
function also checks for duplicate edits, but this may be turned off. The
function {\sf duplicated} is overloaded from the standard {\sf R} function and
the function {\sf isSubset} (pseudocode in Algorithm \ref{algIsSubset}) detects
which edits are a subset or duplicate of another one. In the actual {\sf R}
implementation, the only explicit loop is a call to {\sf R}'s {\sf vapply}
function.  The other loops are avoided using {\sf R}'s indexing  and
vectorization properties.
\index{editarray@{\sf editarray}!redundancy}
%
\begin{algorithm}[t]
\caption{{\sc isSubset}$(E)$}
\label{algIsSubset}
\begin{algorithmic}[1]
\Require An editarray $E=\langle{\bf A},\ind\rangle$.
\State ${\bf s} \leftarrow (\false)^m$
\For {$({\bf a}^{(i)},{\bf a}^{(i')})\in \rows({\bf A})\times\rows({\bf A})$ }
  \If {${\bf a}^{(i)}\lor {\bf a}^{(i')}={\bf a}^{(i')} $}
    \State $s_i\leftarrow\true$
  \EndIf
\EndFor
\Ensure Boolean vector $\bf s$ indicating which edits represented by  {\bf A} are a subset of another edit. 
\end{algorithmic}
\end{algorithm}


Manipulations may also lead to edits of the form $e=D$, in which case every possible
record is invalid, and the editarray has become impossible to satisfy. The function
{\sf isObviouslyInfeasible} detects whether any such edits are present. The function
{\sf isFeasible} checks if the set of edits in it's argument allows at least one
\index{editarray@{\sf editarray}!feasibility}
valid record. This may yield results which are counterintuitive at first glance.
For example, consider set of edits on the domain $D=\{(x,y)\in\{{\sf a},{\sf b}\}\times\{{\sf c},{\sf d}\}\}$.
<<keep.source=true>>=
M <- editarray(c(
    "x %in% c('a','b')",
    "y %in% c('c','d')",
    "if ( x == 'a' ) y == 'c'",
    "if ( x == 'a' ) y != 'c'"))

@
This set of edits is feasible, even though edits $e_1$ and $e_2$ seem contradictory: 
<<>>=
isFeasible(M)
@
The explanation is that $e_1$ and $e_2$ contradict each other only when 
$x={\sf a}$, so
<<keep.source=true>>=
isFeasible(substValue(M,'x','a'))
@
where the function {\sf substValue} is discussed in the next section. One can check
that the record $(x={\sf b},y={\sf d})$ indeed satisfies all edits in ${\sf M}$.

The feasibility check works by eliminating all variables in an {\sf editarray} one by
one until either no edits are left or an obvious contradiction is found. Eliminating
all variables amounts constructing the solution of an error localization problem
in the branch-and-bound algorithm of \cite{waal:2003} where all variables have to be 
adapted. Variable elimination is discussed further in the next section while error localization is discussed
in Section \ref{secErrLocCat}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of categorical restrictions}
The basic operations on sets of categorical edits are value substitution and
variable elimination. The former amounts to adapting the datamodel underlying
the edit set while the latter amounts to deriving relations between variables
not involving the eliminated variable. 

In the next subsection we give an example of value substitution with the {\sf
editrules} package, as well as some background. In subsection
\ref{sscategoryresolution} we describe an elimination method, which appears to
be new to the field of data editing.  In subsection \ref{ssequivalence} it is
shown that the method yields results equivalent to Fellegi and Holt's
elimination method.  Finally, in subsection \ref{sseliminateexample} we give
an example of eliminating variables with the {\sf editrules} package. 
The technical background described in Subsections \ref{sscategoryresolution}
and \ref{ssequivalence} may be skipped on first reading.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Value substitution}
\label{ssvaluesubstitution}
If it is assumed that in a record, one of the variables takes a certain value,
that value may be substituted in the edit rules. In the boolean representation
this amounts to removing all edits which exclude that value, since the record
cannot violate those edits. Secondly, the columns related to the substituted variable,
but not to the substituted category are removed, thus adapting the datamodel to the
new assumption. Algorithm \ref{substValue} gives the pseudocode for reference purposes.
\index{editarray@{\sf editarray}!value substitution}
%
\begin{algorithm}[t]
\caption{{\sc substValue($E$,$k$,$v$)}}
\label{substValue}
\begin{algorithmic}[1]
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$ and a value $v$
    \State $i \leftarrow \ind(k,v)$
    \State ${\bf A}\leftarrow {\bf A}\backslash\{{\bf a}\in\rows({\bf A})\,|\,a_i=\false\}$\Comment{Remove rows not involving $v$ }
    \State ${\bf A} \leftarrow{\bf A}\backslash\{{\bf a}^t_j\in\columns({\bf A})\,|\, j\in\ind(k)\backslash i\}$\Comment{Remove categories $\not=v$}
    \State Update {\bf ind}
    \Ensure $\langle{\bf A},{\bf ind}\rangle$ with $v$ substituted for variable $k$.
\end{algorithmic}
\end{algorithm}
% 

In the {\sf editrules} package, value substitution is performed by the {\sf
substValue} function, which accepts an {\sf editarray}, a variable name and a
category name. In the following example the editmatrix defined in Figure
\ref{Reditarray} is used.
<<echo=true>>=
substValue(E,"gender","female")
@
In this case, the variable {\em gender} is substituted by the value {\sf female}. The rules
concerning $gender={\sf male}$ may be deleted, so here only the datamodel is left with
no multivariate rules left. In fact, the datamodel itself may be reduced, which
can be achieved by setting the option {\sf reduce=TRUE}.
<<>>=
substValue(E,"gender","female",reduce=TRUE)
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variable elimination by category resolution}
\label{sscategoryresolution}
Given two edits $e$ and $e'$, with boolean representations ${\bf a}$ and
${\bf a}'$ respectively.  We define the {\em resolution operator} $\res_k$ as:
\index{resolution operator}
\begin{eqnarray}
\lefteqn{
    {\bf a} \res_k {\bf a}' = {\bf a}_1\land{\bf a}'_1\oplus\cdots\oplus
    {\bf a}_{k-1}\land{\bf a}'_{k-1}}\nonumber\\
&\oplus&    {\bf a}_k\lor{\bf a}'_k\oplus
    {\bf a}_{k+1}\land{\bf a}'_{k+1}\oplus\cdots\oplus
    {\bf a}_n\land{\bf a}'_n.
\label{eqResolutionOperator}
\end{eqnarray}
For two edit sets ${\bf A}$ and ${\bf A'}$, we also introduce the notation
\begin{equation}
{\bf A}\res_k{\bf A}' = \{{\bf a}\res_k{\bf a}'\,|\, ({\bf a},{\bf a}')\in\rows({\bf A})\times\rows({\bf A}')\}.
\end{equation}
%
Observe that the resolution operator has the following properties, relevant for record checking.
\begin{eqnarray}
   {\bf v}\in {\bf a}\res_k{\bf a}' &\Rightarrow& {\bf v}\in{\bf a} \lor {\bf v}\in{\bf a}'\\
   {\bf v}\in {\bf a} &\Rightarrow& \left({\bf v}\in{\bf a}\res_k{\bf a}'\right) \lor \left({\bf a}\res_k{\bf a}'=\varnothing\right),
    \label{eqRedundant}
\end{eqnarray}
where we used notation as defined in remark \ref{remboolnotation}.
That is, if a record violates ${\bf a}\res_k{\bf a}'$, it does so because it
violates ${\bf a}$ and/or ${\bf a}'$. Therefore, ${\bf a}\res_k{\bf a}'$ is
also an edit in the sense that a record is invalid if it is falls in the
derived edit. When ${\bf a}_k={\bf a}'_k$, the resulting edit is
the intersection of the original edits, in which case the resulting edit is
redundant.  

The operator is called resolution operator since in certain cases its action is
equivalent to a resolution operation from formal and automated logic derivation
\citep{robinson:1965}.  If ${\bf a}_k\lor {\bf a}'_k=(\true)^{d_k}$, the
operator ``resolves'' or eliminates the $k^{\rm th}$ variable and we are left
with a relation between the other variables, regardless of the value of
variable $k$. The edit resulting from a resolution operation on two explicitly
defined edits is called an {\em implied edit}. \index{edits!implied} If the
resolution operation happens to eliminate one of the variables, it is called an
{\em essentially new implied edit}.\index{edits!essentially new} These terms
were introduced by \citet{fellegi:1976} who first solved the problem of error	
localization for categorical data. 


\index{editarray@{\sf editarray}!variable elimination}
The resolution operator can be used to eliminate a variable $k$ from a set of
edits (represented by ${\bf A}$) category by category as follows (Algorithm
\ref{eliminate}).  Suppose that $j$ is the column index of the first category
of $k$.  Collect all pairs of $({\bf a}^+,{\bf a}^-)$ obeying $a^+_j=\true$ and
$a^-_j=\false$.  If there are no edits of type ${\bf a}^+$, the variable cannot
be eliminated and the empty set is returned. Otherwise, copy all ${\bf a}^+$ to
a new set of edits and add every ${\bf a}^+\res_k{\bf a}^-$. By construction,
these new edits all have $a_j=\true$. Possibly, redundant edits have been
produced, and these may be removed. The procedure is iterated for every
category of $k$, adding a category for which each $a_j=\true$ at each
iteration.
%
%
\begin{algorithm}[t]
\caption{{\sc eliminate($E$,$k$)}}
\label{eliminate}
\begin{algorithmic}[1]
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$
    \For{$j\in \ind(k)$}
    \State ${\bf A}^+ = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc true}\}$
    \State ${\bf A}^- = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc false}\}$ 
    \If{${\bf A}^+=\varnothing$}
        \State ${\bf A}\leftarrow\varnothing$
        \State {\bf break}
    \EndIf
    \State ${\bf A}\leftarrow {\bf A}^+\cup {\bf A}^+\res_k {\bf A}^-$
    \State Delete rows which have $\textrm{\sc isSubset}(\langle{\bf A},\ind\rangle)=\true$.
    \EndFor
    \Ensure {\sf editarray} $\langle{\bf A},\ind\rangle$ with variable $k$ eliminated
\end{algorithmic}
\end{algorithm}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Some properties of the elimination method}
\label{ssequivalence}
In this subsection we prove that the function {\sc eliminate} of Algorithm 
\ref{eliminate} generates all edits necessary to solve the error localization
problem. A short comparison with the elimination method of \cite{fellegi:1976}
is given as well.

Given a set of $m$ edits:
\begin{equation}
    E = \{ e^{(i)} \in \mathcal{P}(D)\,|\,
    e^{(i)} \textrm{ as in Eq.\ \eqref{eqDefEdit}}
    \textrm{, } 
    i\in 1,2,\ldots,m\},
\label{eqEditSet}
\end{equation}
where $\mathcal{P}(D)$ is the powerset of $D$.  \citet{fellegi:1976}, but also
\cite{waal:2011} define a way to derive new edits, which may be written as a
function $F_k$,
\begin{eqnarray}
\lefteqn{F_k(E) = 
\ocap_{i=1}^m A^{(i)}_1\times
\ocap_{i=1}^m A^{(i)}_2\times\cdots\times
\ocap_{i=1}^m A^{(i)}_{k-1}\times 
}\nonumber\\
&\times& 
\ocup_{i=1}^m A^{(i)}_k\times
\ocap_{i=1}^m A^{(i)}_{k+1}\times
\cdots\times
\ocap_{i=1}^m A^{(i)}_m,
\label{eqFkSetRep}
\end{eqnarray}
where $k$ is called the {\em generating variable}. In the boolean representation, we have
${\bf A}=\rho(E)$. Using the relations $\rho(e\cap e')=\rho({\bf e})\land\rho({\bf e})$
and $\rho(e\cup e')=\rho(e)\lor\rho(e')$ we may write
\begin{equation}
F_k({\bf A}) = {\bf a}^{(1)}\res_k{\bf a}^{(2)}\res_k\cdots\res_k{\bf a}^{(m)},
\quad {\bf a}^{(i)}=\rho\left(e^{(i)}\right),
\label{eqFkBoolRep}
\end{equation}
where we used some obvious properties (symmetry, associativity) of the $\land$
and $\lor$ operators as well. The following lemma and corollary show that we can do
all the work, necessary for implied edit derivation with the resolution operator. 
%
\begin{lemma}[\citet{fellegi:1976}]
If $E$ is a set of edits, every edit, logically implied by $E$ can be derived by repeated application of Eq.\ \eqref{eqFkSetRep}
on subsets of $E$.
\end{lemma}
\begin{proof}
The proof is given in the reference and will not be repeated here.
\end{proof}
\begin{corollary}
If $E$ is a set of edits, all implied edits can be derived by repeated
application of the resolution operator on elements of the boolean
representation of $E$.
\label{corResolution}
\end{corollary}
\begin{proof}
This follows from the equivalence between Eqs.\ \eqref{eqFkSetRep} and \eqref{eqFkBoolRep}.
\end{proof}
%
Having established the use of the resolution operator, it becomes interesting
to study its algebraic properties.  By substitution in the definition, it is
easily shown that the resolution operator is symmetric, associative and
idempotent. As a reminder, these properties are defined as follows.
\begin{equation}
\begin{array}{ll}
\textrm{symmetry:}  &{\bf a}\res_k{\bf b} = {\bf b} \res_k {\bf a} \\
\textrm{associativity:}& ({\bf a}\res_k{\bf b})\res_k {\bf c} = {\bf a}\res_k({\bf b}\res_k {\bf c})\\
\textrm{idempotency:} &{\bf a}\res_k {\bf a} = {\bf a}.
\end{array}
\end{equation}
The resolution operator (although not called as such) was found earlyer and
independently of the current authors by \cite{willenborg:1988}, who also
discovered these properties.
%
The following property shows that the resolution operator leaves redundancy relations untouched.
\begin{lemma}
If ${\bf b}\subseteq {\bf c}$\textrm{, then }${\bf a}\res_k {\bf b}\subseteq {\bf a}\res_k {\bf c}$.
\label{keepRedundancy}
\end{lemma}
\begin{proof}
We may write ${\bf a} = {\bf a}_k\oplus{\bf a}'$ and similarly for {\bf b} and {\bf c}. This gives
\begin{eqnarray*}
{\bf a}\res_k {\bf b} &=& {\bf a}\res_k ({\bf b}\land {\bf c}) \\
&=& {\bf a}_k\lor ({\bf b}_k\land {\bf c}_k) \oplus {\bf a}'\land ({\bf b}'\land{\bf c}')\\
&=& ({\bf a}_k\lor{\bf b}_k)\land ({\bf a}_k\lor{\bf c}_k) \oplus ({\bf a}'\land {\bf b}')\land ({\bf a}'\land{\bf c}')\\
&=& {\bf a}\res_k{\bf b}_k \land {\bf a}\res_k{\bf c} \subseteq {\bf a}\res_j{\bf c},
\end{eqnarray*}
and we are done.
\end{proof}
%
This lemma is important because it shows that removing redundant edits (as shown in Algorithm \ref{eliminate}) 
does not affect the outcome of {\sc eliminate} in the sense that the resulting edit set covers the same subset
of $D$ with or without the redundancy removal step.

We now define more formally the notion of variable elimination.
\begin{definition}
    Given a a function $f:\mathcal{P}(D)\to\mathcal{P}(D)$, and a set of edits $E\subset
    \mathcal{P}(D)$. If none of the edits in $f(E)$ contain variable $k$, we say
    that $f$ eliminates that variable from $E$.
\end{definition}
Remember that in the boolean representation, this means that ${\bf a}_k=(\true)^{d_k}$.
The following theorem shows that every essentially new implied edit, generated by $k$ is found
by Algorithm \ref{eliminate}.
\begin{theorem}s
If $E$ is a set of edits. The function $\textrm{\sc eliminate}(E,k)$ generates
every edit derived from $E$ from which variable $k$ has been eliminated. Moreover, these
edits are mutually non-redundant.
\label{eliminates}
\end{theorem}
\begin{proof}
The rows are mutually non-redundant since redundant rows are removed explicitly in
line 8 of the algorithm. The fact that the removing these rows does not alter the
result (in the sense that the resulting edits will cover the same subdomain of $D$) 
is a consequence of Lemma \ref{keepRedundancy}. 

Denote by ${\bf A}(j)$ the state of {\bf A} after $j$
iterations. We have
\begin{equation}
{\bf A}(1) = {\bf A}^+\cup {\bf A}^+\res_k{\bf A}^-.
\end{equation}
Here ${\bf A}(1)$ contains every nonredundant derived edit with column ${\bf
ind}(k,1)$ equal to \true.  For, if there is another derived edit, by corollary
\ref{corResolution} it must be in ${\bf A}^+\res_k {\bf A}^+$, since
${\bf A}^-\res_k {\bf A}^-$ only generates edits where $a_{\ind(k,1)}=\false$.
Now, consider two edits ${\bf a}^{+}$ and ${\bf a}^{\prime +}\in{\bf
A}^+$.  We have ${\bf a}^+\res_l{\bf a}^{\prime+}\subseteq {{\bf
a}^+\cup {\bf a}^{\prime+}}\subseteq{\bf A}^+\subseteq{\bf A}(1)$ so
each element of ${\bf A}^+\res_k{\bf A}^+$ is redundant (remember Remark \ref{editremark}). It follows from the
definition of $\res_k$ that if ${\bf A}(j-1)$ contains every nonredundant edit
with columns \mbox{$\ind(k,1),\ldots,\ind(k,j-1)$} equal to \true then
${\bf A}(j)$ contains all nonredundant edits with columns
$\ind(k,1),\ldots,\ind(k,j)$ equal to
\true. Since the algorithm iterates over all $j\in\ind(k)$ the result follows.
\end{proof}

It is interesting to compare the procedure in Algorithm \ref{eliminate} with 
Fellegi and Holt's procedure for generating implicit edits. This procedure,
which is also described by \cite{waal:2011} may be summarized as follows.

\vspace{1ex}
\begin{algorithmic}[1]
\Function{\textrm{\sc FH}}{$E$,$k$}
%\Require A set of edits $E$ and a generating variable $k$.
\State Find every $E_j\subseteq E$, with $j\in1,2,\ldots,s$ such that 
\begin{itemize}
\item $F_k(E_j)$ eliminates $k$.
\item $E_j$ has a minimal number of elements $|E_j|$.
\item The $E_j$ are mutually non-redundant in the sense $F_k(E_j)\not\subseteq F_k(E_l)$.
\end{itemize}
\State $E\leftarrow\cup_{j=1}^sF_k(E_j)$
\State \Return $E$
\EndFunction
\end{algorithmic}
\vspace{1ex}
%
Here, $E$ is a set of categorical edits in some form, and $k$ the variable to
eliminate.  Most of the computational complexity is contained in line 2, where
the search space is determined by the power set of $E$, yielding exponential
complexity in the number of edits.

The complexity of the {\sc eliminate} algorithm is determined by the 7th line
in Algorithm \ref{eliminate}, which is quadratic in the current number of edits
in the for-loop. This recurrence relation also yields exponential complexity in
the number of edits. However, by removing the redundant edits at every
iteration (a quadratic operation in itself), the actual number of edits can be
kept to a minimum which reduces the complexity encountered in practice.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{An example with {\sf eliminate}}
\label{sseliminateexample}
\index{editarray@{\sf editarray}!variable elimination}
The purpose of the {\sf eliminate} function is to derive all possible non-redundant
edits from an edit set that do not contain a certain variable. For categorical data
edits, this amounts to logical resolution. For example, consider the syllogism

\begin{tabular}{lm{0.8\textwidth}}
\\
$P_1$ & An under-aged subject cannot be married\\
$P_2$ & A marriage partner has to be married\\
\hline
$C$ & An under-aged subject cannot be a marriage partner.\\   
\\
\end{tabular}\\
Here, the conclusion $C$ is derived from premises $P_1$ and $P_2$ by eliminating
{\em marital status}. In {\sf editrules} the above operation can be performed as
follows. We first define a data model and edit rules:

<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under-aged','adult')",
    "maritalStatus %in% c('married','not married')",
    "positionInHousehold %in% c('partner','child','other')",
    "if (age == 'under-aged') maritalStatus != 'married'",
    "if (positionInHousehold == 'partner') maritalStatus == 'married'"
))
@
We may derive the conclusion by eliminating the {\em marital status} variable:
<<>>=
eliminate(E,'maritalStatus')
@
This indeed yields the right conclusion. Alternatively, we may eliminate {\em age}:
<<>>=
eliminate(E,'age')
@
This deletes the only rule actually involving {\em age}. That is, no new rules not involving
{\em age} can be derived.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization in categorical data}
\label{secErrLocCat}

\subsection{A Branch and bound algorithm}
\label{sBandB}
The editrules package implements an error localization algorithm, based on the
branch-and-bound algorithm of \cite{waal:2003a}. The algorithm has been
extensively described in \cite{waal:2003} and \cite{waal:2011}. The algorithm
is similar to the branch-and-bound algoritm used for error localization in
numerical data in the editrules package as described in \citet{jonge:2011},
except that the elimination and substitution subroutines are implemented for
categorical data.

In short, a binary tree is created with the full set of edits and an erroneous
record at the root node. Two child nodes are created. In the first child node
the first variable of the record is assumed correct, and it's values is
substituted in the edits. In the second child node the variable is assumed
incorrect and it is eliminated from the set of edits. The tree is continued
recursively until choices are made for each variable. Branches are pruned when
they cannot lead to a solution, leaving a partial binary tree where each path
from root to leaf represents a solution to the error localization problem.
Computational complexity is reduced further by pruning branches leading to
higher-weight solutions then solutions found earlier.

Recall the datamodel of Example \ref{datamodel}, with variables {\em marital status},
{\em age} and {\em position in household}. We define the following two edits:

\begin{tabular}{ll}
\\
$e^{(1)}$ & An under-aged subject cannot be married\\
$e^{(2)}$ & A (marriage) partner has to be married\\
\\
\end{tabular}\\
%
As an example we treat the following record with the branch-and-bound algorithm to 
localize the errors:
\begin{equation}
v = ({\sf married},\textrm{\sf under-aged},{\sf partner }).
\end{equation}
At the beginning of the algorithm, only the root node is filled. The situation may be 
represented as follows:\\
%%%%%%%%%%%%%
% T0: ROOT NODE
%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1&0&0&0&1&0&1&0&0\\
        \hline
        {\bf a}^{(1)}&1&0&0&0&1&0&1&1&1\\
        {\bf a}^{(2)}&0&1&1&1&1&1&1&0&0
    \end{array}
$
\end{tabular}\hfill  Root node, $w=0$,
\end{center}
%
where ${\bf v}=\rho(v)$, and ${\bf a}_1$ and ${\bf a}_2$ are the boolean
representations of $e_1$ and $e_2$ respectively. The record and edits are
denoted in boolean representation as shown in Example \ref{datamodel}.  The
weight $w$ counts the number of variables that are assumed to be incorrect,
which at the root node is zero. 


The tree is traversed in depth-first fashion. In the first step, we substitute
{\sf married} in {\em marital status}, yielding
%%%%%%%%%%%
% T0L
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1&0&1&0&0\\
        \hline
       {\bf a}^{(1)}&1 & & & &1&0&1&1&1\\
    \end{array}
$
\end{tabular}\hfill Subst. mar. stat., $w=0$.
\end{center}
Here, ${\bf a}^{(2)}$ is removed, since it has no meaning for {\bf v} anymore. The
positions for the categories unmarried, widowed and divorced are left empty
here to signify that the datamodel has a fixed marital status now. The dark
part of the tree on the left shows which nodes have been treated. Continuing
we find

%%%%%%%%%%%
% T0LL
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1& &1&0&0\\
        \hline
        {\bf a}^{(1)}&1 & & & &1 & &1&1&1\\
    \end{array}
$
\end{tabular}\hfill Subst. age., $w=0$.
\end{center}
At this point we have fixed the value for {\em marital status} and {\em age}.
It can be seen from the value of ${\bf a}^{(1)}$ for {\em position in
household} that no matter what value is chosen for that field, the value ${\bf
v}\cdot{\bf a}^{(1)}=3$. This shows that this path will never lead to a valid
solution.  We therefore prune the tree here, go up one node and turn right. 
%%%%%%%%%%%
% T0LR
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1&0&0\\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Elim. age, $w=1$.
\end{center}
Eliminating the {\em age} variable yields an empty edit set. We may continue down
and substitute the value {\sf partner} for {\em position in household}.
\begin{center}
%%%%%%%%%%%
% T0LRL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1& & \\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Subst. hh. pos., $w=1$.
\end{center}
This yields the first solution: only the {\rm age} variable needs to be
changed.  In search for more solutions, we move up the tree and try to eliminate
{\em age}. However, since eliminating age would increase the weight to 2 we will prune
the tree at this point. Moving up to the root node and eliminating {\em marital status}
gives
%%%%%%%%%%%
% T0R
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&0&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&0&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Elim. mar. stat., $w=1$.
\end{center}
Here ${\bf a}^{(3)}={\bf a}^{(1)}\res_1{\bf a}^{(2)}$. It is interpreted as the
rule that under-aged people cannot be a partner in the household (no matter
what the value of {\em marital status} is).  Creating the next child node by
substituting {\em age}, we get
\begin{center}
%%%%%%%%%%%
% T0RL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&\phantom{0}&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1& 1 &\phantom{0}&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Subst. age, $w=1$.
\end{center}
Going down the tree and substituting {\em position in household} yields
\begin{center}
%%%%%%%%%%%
% T0RLL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Elr\Tlr\Elrl\Tlrl%\Elrr\Tlrr\XTlrr
    \Er\Tr\Erl\Trl\Erll\Trll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&&1&&\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&\phantom{0}&1&\phantom{0}&\phantom{0}\\
    \end{array}
$ 
\end{tabular}\hfill Subst. hh. pos., $w=1$.
\end{center}
However, whatever value we would choose for {\em marital status}, it would
always result in an erroneous record since ${\bf a}^{(3)}$ has \true on all
categories of that variable. Therefore, we go up one step in the tree.
Eliminating {\em age} would increase the weight to 2, but since we already
found a solution with weight equal to 1, this path need not be followed. We go
up another node and bound on the fact that eliminating {\em position in
household} would yield the same problem. The final tree may be represented as
follows:
\begin{center}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl\Erll\Trll\XTrll
\end{picture}$\:$.
\end{center}
Here, every evaluated node is colored black, and a node is crossed when a bound
condition was encountered. The only (minimal) solution created is represented
by the path substitute {\em marital status} $\rightarrow$ eliminate {\em age}
$\rightarrow$ substitute {\em position in household}. This corresponds to the
solution where {\em age} has to be altered to fix the record, and indeed
changing {\em age} from {\sf under-aged} to {\sf adult} will make the record
fully valid. Note that the branch-and-bound algorithm reduced the number of
nodes to be evaluated from $15$ to $8$ in this case.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Error localization with {\sf localizeErrors}}
\label{sslocalizeerrors}
\index{error localization!with {\sf localizeErrors}}
%
%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under-aged','adult')",
    "maritalStatus %in% c('unmarried','married','widowed','divorced')",
    "positionInHousehold %in% c('marriage partner', 'child', 'other')",
    "if( age == 'under-aged' ) maritalStatus == 'unmarried'",
    "if(positionInHousehold == 'marriage partner') maritalStatus == 'married'"
    )
)

(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under-aged','adult','adult' ),
    positionInHousehold=c('child','other','marriage partner')
))

set.seed(1)
localizeErrors(E,dat)
@
\caption{Localizing errors in a {\sf data.frame} of records. The data model is
as defined in Example \ref{datamodel}.  The randseed is set before calling {\sf
localizeErrors} to make results reproducible. The third record has degeneracy 2,
which means that the chosen solution was drawn uniformly from two equivalent
solutions with weight 1.}
\label{RlocalizeErrors}
\end{Rcode}
The function {\sf localizeErrors} applies the branch-and-bound algorithm to
determine the minimal weight error location for every record in a {\sf
data.frame}. The columns may be in {\sf character} or {\sf factor} format.  The
function has an identical interface for numerical data under linear edits and
categorical  data under categorical edits. It is implemented as an {\sf S3}
generic function, accepting either an {\sf editmatrix} or an {\sf editarray} as
the first argument and a {\sf data.frame} as the second argument. Further
arguments are a vector of variable weights, a maximum search time (in seconds)
to spend on a single record, a maximum weight and the maximum number of
variables which may be changed. The latter two arguments introduce extra bound
conditions in the branch-and-bound algorithm.

Even when variables are weighted, the solution to the error localization
problem may not be unique. In those cases {\sf localizeErrors} will draw
uniformly from the set of lowest-weight solutions. The degeneracy (number of
equivalent solutions found) is reported in the output.

The result of a call to {\sf localizeErrors} is an object of class {\sf errorLocation}.
It contains a boolean matrix with error locations for each record as well as a status 
report containing degeneracies, solution weights run times and whether the maximum runtime
was exceeded. It also contains a timestamp (in the form of a {\sf Date} object) and the
name of the user running {\sf R}. Table \ref{tblErrorLocation} gives an overview of
the slots involved.
%
\input{tex/errorLocation.tex}

In Figure \ref{RlocalizeErrors} an example of the use of {\sf localizeErrors} is
given. The data model and rules are as in subsection \ref{sBandB}. The records
are given by
<<keep.source=false,echo=false>>=
(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under-aged','adult','adult' ),
    positionInHousehold=c('child','other','marriage partner')
))
@
The edits state that under-aged cannot be married and that you cannot be a
marriage partner if you're not married. Clearly, the first and third record
disobey some of these rules while the second record is valid. The first
record can be repaired by adapting age and the second record can be made
consistent by changing either {\em position in household} or {\em marital
status}. In the latter case, both solutions have equal weight and {\sf
localizeErrors} has drawn one solution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\subsection{Error localization with {\sf errorLocalizer}}
\label{sserrorlocalizer}
\index{error localization!with {\sf errorLocalizer}}
Just like for linear edits, the function {\sf errorLocalizer} gives more
control over the error localization process since it allows to parameterize
the search separately for each record. This can be useful, for example when 
reliability weights are calculated for each record.

The {\sf errorLocalizer} function is described extensively in
\cite{jonge:2011}, so here we will discuss the example shown Figure
\ref{RcatErrorLocalizer}.

The data model and edits are the same as in Figure \ref{RlocalizeErrors}. The
difference here is that a record must be offered as a named {\sf character}
vector. A call to {\sf errorLocalizer} generates a {\sf backtracker} object
which contains all information necessary to start searching the binary tree.
After calling {\sf \$searchNext()} the weight and first found solution are
returned, while the backtracker object stores some meta-information about the
process, most significantly the duration of the search.  A second call yields a
better solution and the third call returns {\sf NULL}, indicating that all
minimal weight solutions have been found.
%
\begin{Rcode}
<<keep.source=TRUE>>=
# Define a record 
r <- c(age = 'under-aged', maritalStatus='married', positionInHousehold='child')
el <- errorLocalizer(E,r)
el$searchNext()

el$duration
el$maxdurationExceeded
el$searchNext()
el$searchNext()
@
\caption{Finding errors with {\sf errorLocalizer}. The data model and edits in {\sf E} are as in
Figure \ref{RlocalizeErrors}.}
\label{RcatErrorLocalizer}
\end{Rcode}


%\clearpage
\section{Conclusions}
This paper describes the theory and implementation of categorical edit
manipulation of the {\sf editrules} package. Categorical restrictions may be
defined textually in standard {\sf R} syntax. New edits may be derived with the
resolution method. A new formulation of the elimination method in terms of the
resolution operator was developed which facilitated the development of a fast
elimination algorithm which seems to be new in the field of data editing.

The package offers functionality to check records against rules and can 
determine the location of errors based on the generalized principle of 
Fellegi and Holt. 

\clearpage
\bibliographystyle{chicago}
\bibliography{editrules}

\clearpage

\appendix
\section{Notation}
\begin{table}[h]
\begin{tabular}{lp{0.8\textwidth}}
\hline
Symbol          & Explanation and reference\\
\hline
$\oplus$        & Direct vector sum.\\
${\bf a}$       & An edit, in boolean representation: ${\bf a}=\rho(e)$, Eq.\ \eqref{EqRhoE}.\\
${\bf a}_k$     & Boolean representation of one variable in {$\bf a$}. ${\bf a}=\oplus_{k=1}^n{\bf a}_k$.\\
${\bf A}$       & Set of edits, in $m\times d$ boolean representation.\\
$D$             & Set (domain) of all possible categorical records, Eq.\ \eqref{eqDomain}.\\
$D_k$           & Set of possible categories for variable $k$. Eq.\ \eqref{eqVariableDomain}.\\
$d$             & Number of categories (in total), Eq.\ \eqref{eqSumdk}.\\
$d_k$           & Number of categories in $D_k$.\\ 
$e$             & An edit, in set representation: $e\subseteq D$, [Eq.\ \eqref{eqDefEdit}].\\
$E$             & An editarray, Eq.\ \eqref{eqEditarray}, or a set of edits in set representation.\\
$\ind$          & Function relating categories $c$ of variable $k$ to columns in {\bf A}, Eqs.\eqref{eqInd1} and \eqref{eqInd2}.\\
$i$             & row index in {\bf A} (labeling edits).\\
$j$             & column index in {\bf A} (labeling categories).\\
$k$             & Labels a categorical variable.\\
$m$             & Number of edits.\\
$n$             & Number of variables.\\
$\res_k$        & Resolution operator Eq.\ \eqref{eqResolutionOperator}.\\
$\rho$          & Map, sending set representation to boolean representation. \\
$v$             & Categorical record, in set representation: $v=(v_1,\ldots,v_n)\in D$.\\
$v_k$           & Label for a single category of $D_k$. \\
${\bf v}$       & Categorical record, in boolean representation: ${\bf v} = \rho(v)$.\\
${\bf v}_k$     & Boolean representation of a single variable ${\bf v}=\oplus_{k=1}^n{\bf v}_k$.\\
\hline
\end{tabular}
\end{table}

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex



\end{document}


