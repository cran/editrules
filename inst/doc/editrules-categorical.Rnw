%\VignetteIndexEntry{Manipulation of categorical data edits and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage{inconsolata}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }


\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t!}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical data edits and error localization with the
    {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
Analyses of categorical data are often hindered by the occurrence of
inconsistent or incomplete raw data. Although {\sf R} has many features for
analyzing categorical data, the functionality for error localization and error
correction are currently limited.  The {\sf editrules} package is designed to
offer a user-friendly toolbox for edit definition, manipulation, and error
localization based on the generalized paradigm of Fellegi and Holt.  

This is the second paper describing functionalities of the {\sf R} {\sf
editrules} package and marks the completion of {\sf editrules} version $2.0$.
The first paper \citep{jonge:2011} describes methods and implementation for
handling numerical data while this paper is concerned with handling categorical
data. 

{\em For package version 2.0-0, this vignette is a near literal 
    transcript of \cite{loo:2011b}. Please refer to that paper
    when referencing categorical data handling with {\sf editrules}.
    This vignette will be updated with the package if necessary.}

\end{abstract}

\newpage
\tableofcontents
\listofalgorithms

\newpage


\section{Introduction}
\label{sIntroduction}
Analyses of categorical data are often hindered by occurrences of incomplete or
inconsistent raw data records.  The process of locating and correcting such
errors is referred to as {\em data editing}, and it has been estimated that
National Statistics Institutes spend up to 40\% of their resources on this
process \citep{waal:2011}. For this reason, considerable attention is paid to
the development of data editing methods that can be automated. Since data are
often required to obey many interrelated consistency rules, data
editing can be too complex to perform manually. \citet{winkler:1999} mentions
practical cases where records have to obey 250, 300 or even 750 internal
consistency rules.  Although the {\sf R} statistical environment has numerous
facilities for analyzing categorical data [See {\em e.g.} \citet{husson:2010}],
the options for error localization and record correction are currently limited.

This paper presents version 2.0 of {\sf R} package {\sf editrules}, which was
developed to help closing the gap between raw data retrieval and data analysis
with {\sf R}.  The main purpose of the {\sf editrules} package is to provide a
user-friendly environment for handling data restriction rules, to apply those
rules to data, and to localize erroneous fields in data based on the
generalized principle of \cite{fellegi:1976}.  The package does not offer
functionality for data correction. However, it does facilitate the
identification of the set of solutions for an error correction problem.

Under the hood, the package contains several innovations with respect to the
branch-and-bound algorithm for error localization in categorical data described
in \cite{waal:2011}. The most important innovation is a new variable
elimination algorithm of which allows for on-the-fly redundant rule removal.
The algorithm itself will be reported in a forthcoming paper.

The current paper complements our previous paper on the treatment of numerical
data \citep{jonge:2011}. We describe some of the algorithms underlying {\sf
editrules}' functionality and the internal representation of categorical data.
Examples in {\sf R} code are given throughout the text to assist new users in
getting started with the package.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Categorical data and edit rules}
The value domain of categorical data records is usually limited by rules
interrelating these variables.  The simplest examples are cases where the value
of one variable excludes values of another variable. For example: if the age
class of a person is ``child'', then (by law) the marital status cannot be
``married''. In survey or administrative data, violations of such rules are
frequently encountered. Resolving such violations is an important step prior to
data analysis and estimation.

In this section we describe the representation of edits and records as
implemented in the {\sf editrules} package and we report on the basic
(low-level) edit rule manipulation functionality.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Describing records and edit rules}
A record of $n$ categorical variables can be written as an element
of the cartesian product space $D$:
\begin{equation}
\label{eqDomain}
D = D_1\times D_2\times\cdots\times D_n,
\end{equation}
\index{domain}\index{data model}
where each $D_k$ is the set of possible categories for variable $k$.  The
domain of values $D$ is often referred to as the {\em data model} for a
dataset. The number of categories for variable $k$ is labeled $d_k$ while the
total number of categories is labeled $d$, given by
\begin{equation}
d=\sum_{k=1}^n d_k.
\end{equation}
As an example, consider the domain of a record consisting of the variables {\em
marital status}, {\em age} and {\em position in household}, so that
$D=D_1\times D_2\times D_3$:
\begin{eqnarray}
\label{eqdom1}
D_1 &=& \{\textrm{\sf married}, \textrm{\sf unmarried}, \textrm{\sf widowed}, \textrm{\sf divorced}\}\\
\label{eqdom2}
D_2 &=& \{\textrm{\sf under-aged}, \textrm{\sf adult}\}\\
\label{eqdom3}
D_3 &=& \{\textrm{\sf spouse},\textrm{\sf child},\textrm{\sf other}\}.
\end{eqnarray}
In total, there are $d_1\cdot d_2\cdot d_3=4\cdot2\cdot3=24$ records in $D$.

To represent a record, we construct an index vector in $\{0,1\}^d$
indicating the categories in a record. For example, the record:
\begin{equation}
(\textrm{\sf married}, \textrm{\sf adult}, \textrm{\sf spouse}).
\end{equation}
can be represented as
\begin{equation}
(1,0,0,0)\oplus(0,1)\oplus(1,0,0) = (1,0,0,0,0,1,1,0,0),
\end{equation}
where $\oplus$ is the direct vector sum. Note that the position of the 1's
indicate which value each variable has. In this representation, a record with
$n$ variables has precisely $n$ 1's and the rest 0's. We will refer to this
representation of categorical records as the {\em boolean representation},
\index{boolean representation!of records}
since the 1's and 0's can be interpreted as \true and \false respectively.  We
show below that it is useful to allow boolean operations (and, or, negation) on
such vectors.

In practical cases, not every record in a domain, defined as in [Eq.\ \eqref{eqDomain}]
will be valid. For example, we may want to exclude records such as
\begin{equation}
(\textrm{\sf married}, \textrm{\sf under-aged}, \textrm{\sf spouse}),
\end{equation}
since by law, under-aged people cannot be married. 

In general, a data consistency rule, (called {\em edit rule} or {\em edit} in
short) $e$ is a subset of $D$, with the interpretation that if a record falls
in $e$, it is invalid. Every edit can be written in the form
\begin{equation}
\label{eqEditSetRep}
e = A_1\times A_2\times\cdots A_n,
\end{equation}
where each $A_k\subseteq D$. For example, the rules which states:
\begin{equation}
\textrm{under-aged persons cannot be married},
\end{equation}
can be written as
\begin{equation}
\label{eqeditexample}
\{\textrm{\sf married}\}\times \{\textrm{\sf under-aged}\}\times\{\textrm{\sf spouse}, \textrm{\sf child}, \textrm{\sf other}\}.
\end{equation}
Just like records, edits can be represented with boolean vectors where the $1$s indicates which
categories are a member of the edit. The edit in \eqref{eqeditexample} can be represented as
\begin{equation}
(1,0,0,0)\oplus(1,0)\oplus(1,1,1) = (1,0,0,0,1,0,1,1,1).
\end{equation}
\index{boolean representation!of edits}
In {\sf editrules}, edits are represented as boolean vectors. A set of edits is represented
as two-dimensional array, where each row represents a single edit.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The {\sf editarray} object}
\label{sseditarray}
\index{editarray@{\sf editarray}}
In the {\sf editrules} package, a set of categorical edits is storeed as an {\sf editarray}
object. We denote an {\sf editarray} $E$ for $n$ categorical variables and $m$ edits as
(brackets indicate a combination of objects)  
\begin{equation}
    E = \langle {\bf A},{\bf ind}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k,
    \label{eqEditarray}
\end{equation}
Each row ${\bf a}$ of ${\bf A}$ contains the boolean representation of one edit, and the
$d_k$ denote the number of categories of each variable.  The object {\bf ind}
is a nested {\sf list} which relates columns of {\bf A} to variable names and
categories.  Labeling variables with $k\in1,2,\ldots,n$ and category values
with $v_k\in 1,2,\ldots,d_k$, we use the following notations:
\begin{eqnarray}
\label{eqInd1}
    {\bf ind}(k,v_k) &=& \sum_{l< k }d_l + v_k\\
    {\bf ind}(k)   &=& \{{\bf ind}(k,v_k)\,|\, v_k\in D_k\}.
\label{eqInd2}
\end{eqnarray}
So $\ind(k,v_k)$ is the column index in {\bf A} for variable $k$ and category $v_k$
and $\ind(k)$ is the set of column indices corresponding to all categories of
variable $k$.  The {\sf editarray} is the central object for computing with
categorical edits, just like the {\sf editmatrix} is the central object for
computations with linear edits [\cite{jonge:2011}].

It is both tedious and error prone to define and maintain an {\sf editarray} by
hand.  In practice, categorical edits are usually stated verbosely, such as:
``a man cannot be pregnant'', or ``an under-aged person cannot be married''.
To facilitate the definition of edit arrays, {\sf editrules} is equipped with a
parser which takes {\sf R}-statements in {\sf character} and translates them to
an {\sf editarray}.

%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
datamodel(E)
@
\caption{Defining a simple {\sf editarray} with the {\sf editarray} function.
The array is printed with abbreviated column heads, which themselves consist of
variable names and categories separated by a colon (by default). When printed
to screen, a {\sf character} version of the edits is shown as well, for
readability.
}
\label{Reditarray}
\end{Rcode}
%
Figure \ref{Reditarray} shows a simple example of defining an {\sf editarray} with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the domain. The {\sf editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) or multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. 

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\sf <abbreviated var. name><separator><abbreviated cat. label>}
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\sf :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\sf sep} argument to {\sf editarray}.
For convenience, the function {\sf datamodel} accepts an {\sf editarray} as
input and returns an overview of variables and their categories for easy
inspection in the form of a {\sf data.frame}.

Internally, {\sf editarray} uses the {\sf R} internal {\sf parse} function to
transform a {\sf character} expressions to a parse tree. This tree is
subsequently traversed recursively to derive the entries of the {\sf
editarray}. The reverse operation is also implemented. The {\sf R} internal
function {\sf as.character} has been overloaded to derive a {\sf character}
representation from a boolean representation. When printed to the screen, both
the boolean and textual representation are shown.

Univariate edits define the domain of a single variable.  Together, these
domains form a data model. A domain can be defined with common {\sf R} syntax
using the ${\sf \%in\%}$ operator. If a domain is defined explicitly, the edit
must follow the following syntax diagram.
\begin{syntdiag}
    "\""
    <variable> "\%in\%"
    \begin{stack}
        "c("\begin{rep}\syncat\\","\end{rep}")"\\
        <identifier>\\
        "c(TRUE, FALSE)"
    \end{stack}
    "\""
\end{syntdiag}
Here, $\langle variable\rangle$ is the name of a categorical variable, and
$\langle category\rangle$ is a literal category name. Note that the category
name is enclosed by single quotes while the entire statement is between double
quotes.  So here, the entire statement is offered in string format to {\sf
editarray}. The $\langle identifier\rangle$ is the name of a predefined {\sf
character} variable storing the unique categories for a variable. The suymbol
$\langle identifier\rangle$ denotes a previously defined {\sf R} {\sf
character} or {\sf factor} vector listing categories for a variable. Since the
$\langle identifier\rangle$ is evaluated as an expression, in principle any
{\sf R} expression evaluating to a {\sf character} or {\sf factor} vector may
be used as well. However, we do not recommend such constructions since they
clutter a clear definition of the datamodel.

Multivariate rules can be defined in two ways. The most useful and common
way to define edits follows the following syntax diagram.
\begin{syntdiag}
    "\"if ("\begin{rep}
          <set expression>\\
          \begin{stack}"\&\&"\\ "\&"\end{stack}
       \end{rep}
        ")"
        \begin{stack}
            \begin{rep}
                <set expression>\\
                \begin{stack}"||"\\ "|"\end{stack}
            \end{rep} \\
        {\sc false}
        \end{stack}
    "\""
\end{syntdiag}
%
Where each $\langle$\textit{set expression}$\rangle$ is a logical statement following
%
\begin{syntdiag}
    \begin{stack}
        \\"!"
    \end{stack}
        <variable>
        \begin{stack}
            \\
            \begin{stack} "=="\\ "!="\end{stack} 
                \begin{stack} \syncat \\ \begin{stack}\true\\ \false\end{stack}\end{stack}\\
                    "\%in\%"
                    \begin{stack} 
                        "c(" \begin{rep}\syncat\\ "," \end{rep} ")"\\
                        <identifier>\\
                        \begin{stack} \true\\ \false\end{stack}
                    \end{stack}
        \end{stack}
\end{syntdiag}

The reader can check that the examples given in Figure \ref{Reditarray} follow this syntax.
The example below illustrates the use of separately defined data models and boolean
categories.
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
( M <- editarray(c( 
    "x %in% xval",
    "y %in% yval",
    "if ( x %in% c('a','b') ) !y "
    )) )
@
%
The second way to define multivariate edits is based on rewriting on the basic classical
logic law $P\Rightarrow Q = \lnot P\lor Q$. It involves the following syntax diagram.
\begin{syntdiag}
        "\""
        \begin{rep}
          <set expression>\\
          \begin{stack}"||"\\ "|"\end{stack}
        \end{rep} "\""
\end{syntdiag}
Where each $\langle set\:expression\rangle$ is as in the syntax diagram above.  In
practice, a user will commonly not use this form since it is less readable.
However, the {\sf as.character} method for {\sf editarray} can generate such
statements by passing the argument {\sf useIf=FALSE}, as shown below.
<<>>=
as.character(M,useIf=FALSE)
@
The main advantage of this form is that
contrary to the  {\sf if()} form, it allows for vectorized checking of edits,
which is why it is used internally.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coercion, checking, redundancy and feasibility}
\label{sscommonfunctions}
The {\sf editrules} package is equipped with functions operating on sets of
edits represented as an {\sf editarray}. An overview is given in Table
\ref{tabBasicfunctions}.  

The {\sf datamodel} function extracts the variables and categories from an {\sf
editarray}, and returns them as a two-column {\sf data.frame}. With {\sf
as.data.frame} or {\sf as.character} one can coerce an editarray so that it can
be written to a file or database. Character coercion is also used when edits
are printed to the screen. Coercing the data model to character form can be
switched off by passing the option {\sf datamodel=FALSE} to {\sf
as.character}. The result of {\sf as.data.frame} has columns with edit names, a
character representation of the edits and a column for remarks.

The function {\sf violatedEdits} takes an {\sf editarray} and a {\sf
data.frame} as input and returns a logical matrix indicating which record
(rows) violate which edits (columns). It works by parsing the {\sf editarray}
to R-expressions and evaluating them as logical expressions within the {\sf
data.frame} environment. By default, the records are checked against the data
model. This can be turned off by providing the optional argument {\sf
datamodel=FALSE}. 

\index{editarray@{\sf editarray}!functions}
\begin{table}
\begin{threeparttable}
\caption{Functions for objects of class {\sf editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments. The functions are described in the subsections indicated between 
square brackets.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\sf datamodel(E)}            & get datamodel [\ref{sscommonfunctions}] \\
{\sf getVars(E)}              & get a list of variables\\
{\sf as.data.frame(E)}        & coerce edits to {\sf data.frame}\\
{\sf contains(E)}             & which edits contains which variable\\
{\sf as.character(E)}         & coerce edits to {\sf character} vector [\ref{sseditarray}]\\
{\sf blocks(E)}               & Get list of independent blocks of edits\\
{\sf reduce(E)}               & Remove redundant variables and rows [\ref{ssvaluesubstitution}]\\
{\sf isObviouslyRedundant(E)} & find redundancies, duplicates [\ref{sscommonfunctions}]\\
{\sf duplicated(E)}           & find duplicate edits [\ref{sscommonfunctions}]\\
{\sf isSubset(E)}             & find edits, subset of another edit [\ref{sscommonfunctions}]\\
{\sf isObviouslyInfeasible(E)}& detect simple contradictions [\ref{sscommonfunctions}]\\ 
{\sf isFeasible(E)}           & check edit set consistency [\ref{sscommonfunctions}]\\
{\sf substValue(E,var,value)} & substitute a value [\ref{ssvaluesubstitution}]\\
{\sf eliminate(E,var)}        & eliminate a variable [\ref{sseliminate}]\\
{\sf violatedEdits(E,dat)}    & check which edits are violated by {\sf dat} [\ref{sscommonfunctions}]\\
{\sf localizeErrors(E,dat)}   & localize errors [\ref{sslocalizeerrors}]\\
{\sf errorLocalizer(E,x)}     & {\sf backtracker} for error localization [\ref{sserrorlocalizer}]\\
{\sf summary(E)}              & summarize the content of {\sf E}\\
{\sf plot(E)}                 & plot a graph of {\sf E} (requires {\sf igraph} package)\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}


When manipulating edit sets, some edits may become redundant. We distinguish
two redundancy situations. The first situation occurs when an edit $e$ of the
form in Eq.\ \eqref{eqEditSetRep} has $A_k=\varnothing$ for at least one
variable $k$.  In this case, no record can ever be an element of $e$, making
$e$ obsolete.  Such edits can be removed from a set of edits without harming
any further processing or record checking. The second situation occurs when
every record in an edit is also a member of a second edit.  In this case,
the first edit is redundant with respect to the second. The second case can
easily be detected in the boolean representation, for if ${\bf a}$ and ${\bf
b}$ are edits in the boolean representation, then ${\bf a}$ is redundant with
respect to ${\bf b}$ if ${\bf a}\land{\bf b}={\bf a}$, or equivalently when
${\bf a}\lor{\bf b}={\bf b}$. Here, the logical operators $\land$ and $\lor$
work elementwise on the boolean vectors.

In {\sf editrules}, the first type of redundancy can be detected in the boolean
representation with {\sf isObviouslyRedundant}. By default, this function also
checks for duplicate edits, but this may be switched off with an extra
parameter.  Also, the standard {\sf R} function {\sf duplicated} has been
overloaded to search for duplicate edits in an {\sf editarray} directly.  The
second type of redundancy can be detected with the function {\sf isSubset}.
The pseudocode is given in Algorithm \ref{algIsSubset}. In the actual {\sf R}
implementation, the only explicit loop is a call to {\sf R}'s {\sf vapply}
function.  The other loops are avoided using {\sf R}'s indexing  and
vectorization properties.  \index{editarray@{\sf editarray}!redundancy}
%
\begin{algorithm}[t]
\caption{{\sc isSubset}$(E)$}
\label{algIsSubset}
\begin{algorithmic}[1]
\Require An editarray $E=\langle{\bf A},\ind\rangle$.
\State ${\bf s} \leftarrow (\false)^m$
\For {$({\bf a}^{(i)},{\bf a}^{(i')})\in \rows({\bf A})\times\rows({\bf A})$ }
  \If {${\bf a}^{(i)}\lor {\bf a}^{(i')}={\bf a}^{(i')} $}
    \State $s_i\leftarrow\true$
  \EndIf
\EndFor
\Ensure Boolean vector $\bf s$ indicating which edits represented by  {\bf A} are a subset of another edit. 
\end{algorithmic}
\end{algorithm}


Manipulations may also lead to edits of the form $e=D$, in which case every
possible record is invalid, and the editarray has become impossible to satisfy.
The function {\sf isObviouslyInfeasible} detects whether any such edits are
present. The function {\sf isFeasible} checks if the set of edits in its
argument allows at least one \index{editarray@{\sf editarray}!feasibility}
valid record. This may yield results which are counterintuitive at first
glance.  For example, consider a set of edits on the domain $D=\{(x,y)\in\{{\sf
a},{\sf b}\}\times\{{\sf c},{\sf d}\}\}$.
<<keep.source=true>>=
M <- editarray(c(
    "x %in% c('a','b')",
    "y %in% c('c','d')",
    "if ( x == 'a' ) y == 'c'",
    "if ( x == 'a' ) y != 'c'"))

@
This set of edits is feasible, even though edits $e_1$ and $e_2$ seem to contradict each other: 
<<>>=
isFeasible(M)
@
The explanation is that $e_1$ and $e_2$ contradict each other only when 
$x={\sf a}$, so
<<keep.source=true>>=
isFeasible(substValue(M,'x','a'))
@
where the function {\sf substValue} is discussed in the next section. One can check
that the record $(x={\sf b},y={\sf d})$ indeed satisfies all edits in ${\sf M}$.

The feasibility check works by eliminating all variables in an {\sf editarray}
one by one until either no edits are left or an obvious contradiction is found.
Variable elimination is discussed further in section \ref{sseliminate}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of categorical restrictions}
The basic operations on sets of categorical edits are value substitution and
variable elimination. The former amounts to adapting the datamodel underlying
the edit set while the latter amounts to deriving relations between variables
not involving the eliminated variable. 

In the next subsection we give an example of value substitution with the {\sf
editrules} package, as well as some background. Subsection \ref{sseliminate} we
give an example of eliminating variables with the {\sf editrules} package. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Value substitution}
\label{ssvaluesubstitution}
If it is assumed that in a record one of the variables takes a fixed value,
that value may be substituted in the edit rules. In the boolean representation
this amounts to removing all edits which exclude that value, since the record
cannot violate those edits. Secondly, the columns related to the substituted
variable but not to the substituted category are removed, thereby adapting the
datamodel to the new assumption. Algorithm \ref{substValue} gives the
pseudocode for reference purposes.
\index{editarray@{\sf editarray}!value substitution}
%
\begin{algorithm}[t]
\caption{{\sc substValue($E$,$k$,$v$)}}
\label{substValue}
\begin{algorithmic}[1]
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$ and a value $v$
    \State $i \leftarrow \ind(k,v)$
    \State ${\bf A}\leftarrow {\bf A}\backslash\{{\bf a}\in\rows({\bf A})\,|\,a_i=\false\}$\Comment{Remove rows not involving $v$ }
    \State ${\bf A} \leftarrow{\bf A}\backslash\{{\bf a}^t_j\in\columns({\bf A})\,|\, j\in\ind(k)\backslash i\}$\Comment{Remove categories $\not=v$}
    \State Update {\bf ind}
    \Ensure $\langle{\bf A},{\bf ind}\rangle$ with $v$ substituted for variable $k$.
\end{algorithmic}
\end{algorithm}
% 

In the {\sf editrules} package, value substitution is performed by the {\sf
substValue} function, which accepts an {\sf editarray}, a variable name and a
category name. In the following example the editmatrix defined in Figure
\ref{Reditarray} is used.
<<echo=true>>=
substValue(E,"gender","female")
@
In this case, the variable {\em gender} is substituted by the value {\sf female}. The rules
concerning $gender={\sf male}$ may be deleted, so here only the datamodel is left without
any multivariate rules. In fact, the datamodel itself may be reduced, which
can be achieved by setting the option {\sf reduce=TRUE}.
<<>>=
substValue(E,"gender","female",reduce=TRUE)
@
Here, the only option left for {\em gender} is included explicitly in the datamodel. For
some operations it is necessary to remove such redundancies as well. The function {\sf reduce}
completely removes variables from an edit set for which the value has been fixed:
<<>>=
reduce(substValue(E,"gender","female"))
@
The substitution renders the only edit rule obsolete. Since after the
substitution, there are no limitations on the variable {\em pregnant}, (except
for the datamodel) this variable is deleted from the editarray as well.   The
{\sf reduce} function is used extensively in the deductive imputation routines
of the {\sf deducorrect} package \citep{loo:2011c}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elimination of variables}
\label{sseliminate}
\index{editarray@{\sf editarray}!variable elimination}
The purpose of the {\sf eliminate} function is to derive all possible
non-redundant edits from an edit set that do not contain a certain variable.
For categorical data edits, this amounts to a series of logic resolution
operations. As an example, consider the following syllogism:

\begin{tabular}{lm{0.8\textwidth}}
\\
$P_1$ & An Under-aged person cannot be married\\
$P_2$ & A spouse has to be married\\
\hline
$C$ & An under-aged person cannot be a spouse.\\   
\\
\end{tabular}\\
Here, the conclusion $C$ following from premises $P_1$ and $P_2$ does not contain
the variable {\em marital status} anymore. That is, {\em marital status} is eliminated.

To generalize this operation, note that using Eqs. \eqref{eqdom1}-\eqref{eqdom3}, 
the above syllogism can be written as
\begin{equation}
\label{eqsyllogism}
\begin{array}{ccccc}
\{\textrm{\sf married}\} &\times & \{\textrm{\sf under-aged}\} &\times& D_3\\
\{\textrm{\sf unmarried},\textrm{\sf widowed},\textrm{divorced}\} &\times&D_2 &\times&\{\textrm{\sf spouse}\} \\
\hline
D_1 &\times&\{\textrm{\sf under-aged}\} &\times& \{\textrm{\sf spouse}\}.
\end{array}
\end{equation}
Note that the resulting edit is derived by taking the set union in the first
variable and the set intersection in the other variables. A generalized version
of this operation was first described in the context of error localization by
\cite{fellegi:1976}.  They also devised a combinatorial algorithm that
generates every edit from an edit set that does not contain some chosen
variable. The elimination algorithm in {\sf editrules} is different, and is
based on repeated application of the binary operation shown in Eq.\
\eqref{eqsyllogism}. The details of this algorithm will be published in a
forthcoming paper.


In {\sf editrules} the above operation can be performed as
follows. We first define a data model and edit rules:
<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under-aged','adult')",
    "maritalStatus %in% c('married','not married')",
    "positionInHousehold %in% c('spouse','child','other')",
    "if (age == 'under-aged') maritalStatus != 'married'",
    "if (positionInHousehold == 'spouse') maritalStatus == 'married'"
))
@
We may derive the conclusion by eliminating the {\em marital status} variable:
<<>>=
eliminate(E,'maritalStatus')
@
This indeed yields the right conclusion. Alternatively, we may eliminate {\em age}:
<<>>=
eliminate(E,'age')
@
This deletes the only rule actually involving {\em age}. That is, no new rules not involving
{\em age} can be derived.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization in categorical data}
\label{secErrLocCat}

\subsection{A Branch and bound algorithm}
\label{sBandB}
The editrules package implements an error localization algorithm, based on the
branch-and-bound algorithm of \cite{waal:2003a}. The algorithm has been
extensively described in \cite{waal:2003} and \cite{waal:2011}. The algorithm
is similar to the branch-and-bound algorithm used for error localization in
numerical data in the editrules package as described in \citet{jonge:2011},
except that the elimination and substitution subroutines are implemented for
categorical data.

In short, a binary tree is created with the full set of edits and an erroneous
record at the root node. Two child nodes are created. In the first child node
the first variable of the record is assumed correct, and its values is
substituted in the edits. In the second child node the variable is assumed
incorrect and it is eliminated from the set of edits. The tree is continued
recursively until choices are made for each variable. Branches are pruned when
they cannot lead to a solution, leaving a partial binary tree where each path
from root to leaf represents a solution to the error localization problem.
Computational complexity is reduced further by pruning branches leading to
higher-weight solutions then solutions found earlier.

Recall the datamodel of Eqs.\ \eqref{eqdom1}-\eqref{eqdom3}, with variables {\em marital status},
{\em age} and {\em position in household}. We define the following two edits:

\begin{tabular}{ll}
\\
$e^{(1)}$ & An under-aged person cannot be married\\
$e^{(2)}$ & A spouse has to be married\\
\\
\end{tabular}\\
%
As an example we treat the following record with the branch-and-bound algorithm to 
localize the errors:
\begin{equation}
({\sf married},\textrm{\sf under-aged},{\sf spouse }).
\label{eqrecord}
\end{equation}
At the beginning of the algorithm, only the root node is filled. The situation may be 
represented as follows:\\
%%%%%%%%%%%%%
% T0: ROOT NODE
%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
&\multicolumn{4}{c}{mar.\:stat.}&\multicolumn{2}{|c|}{age}&\multicolumn{3}{c}{pos.\:in\:hh}\\
        {\bf v}  &1&0&0&0&1&0&1&0&0\\
        \hline
        {\bf a}^{(1)}&1&0&0&0&1&0&1&1&1\\
        {\bf a}^{(2)}&0&1&1&1&1&1&1&0&0
    \end{array}
$
\end{tabular}\hfill  Root node, $w=0$,
\end{center}
%
where ${\bf v}$ is the boolean representation of the record, and ${\bf
a}^{(1)}$ and ${\bf a}^{(2)}$ are the boolean representations of $e^{(1)}$ and
$e^{(2)}$ respectively. The weight $w$ counts the number of variables that are
assumed to be incorrect, which at the root node is zero. 


The tree is traversed in depth-first fashion. In the first step, we substitute
{\sf married} in {\em marital status}, yielding
%%%%%%%%%%%
% T0L
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1&0&1&0&0\\
        \hline
       {\bf a}^{(1)}&1 & & & &1&0&1&1&1\\
    \end{array}
$
\end{tabular}\hfill Subst. mar. stat., $w=0$.
\end{center}
Here, ${\bf a}^{(2)}$ is removed, since it has no meaning for {\bf v} anymore. The
positions for the categories unmarried, widowed and divorced are left empty
here to signify that the datamodel has a fixed marital status now. The dark
part of the tree on the left shows which nodes have been treated. Continuing
we find

%%%%%%%%%%%
% T0LL
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1& &1&0&0\\
        \hline
        {\bf a}^{(1)}&1 & & & &1 & &1&1&1\\
    \end{array}
$
\end{tabular}\hfill Subst. age., $w=0$.
\end{center}
At this point we have fixed the value for {\em marital status} and {\em age}.
It can be seen from the value of ${\bf a}^{(1)}$ for {\em position in
household} that no matter what value is chosen for that field in {\bf v}, the
resulting record will always fall in ${\bf a}^{(1)}$. This shows that this path
will never lead to a valid solution.  We therefore prune the tree here, go up
one node and turn right. 
%%%%%%%%%%%
% T0LR
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1&0&0\\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Elim. age, $w=1$.
\end{center}
Eliminating the {\em age} variable yields an empty edit set. We may continue down
and substitute the value {\sf spouse} for {\em position in household}.
\begin{center}
%%%%%%%%%%%
% T0LRL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1& & \\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Subst. hh. pos., $w=1$.
\end{center}
This yields the first solution: only the {\rm age} variable needs to be
changed.  In search for more solutions, we move up the tree and try to
eliminate {\em position in household}. However, since eliminating {\em position
in household} would increase the weight to 2 we will prune the tree at this
point. Moving up to the root node and eliminating {\em marital status} gives
%%%%%%%%%%%
% T0R
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&0&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&0&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Elim. mar. stat., $w=1$.
\end{center}
where ${\bf a}^{(3)}$  is the derived edit. It is interpreted as the rule that
under-aged people cannot be a partner in the household (no matter what the
value of {\em marital status} is).  Creating the next child node by
substituting {\em age}, we get
\begin{center}
%%%%%%%%%%%
% T0RL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&\phantom{0}&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1& 1 &\phantom{0}&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Subst. age, $w=1$.
\end{center}
Going down the tree and substituting {\em position in household} yields
\begin{center}
%%%%%%%%%%%
% T0RLL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Elr\Tlr\Elrl\Tlrl%\Elrr\Tlrr\XTlrr
    \Er\Tr\Erl\Trl\Erll\Trll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&&1&&\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&\phantom{0}&1&\phantom{0}&\phantom{0}\\
    \end{array}
$ 
\end{tabular}\hfill Subst. hh. pos., $w=1$.
\end{center}
However, whatever value we would choose for {\em marital status}, it would
always result in an erroneous record since ${\bf a}^{(3)}$ has \true on all
categories of that variable. Therefore, we go up one step in the tree.
Eliminating {\em position in household} would increase the weight to 2, but
since we already found a solution with weight equal to 1, this path need not be
followed. We go up another node and bound on the fact that eliminating {\em
age} would yield the same problem. The final tree may be represented as
follows:
\begin{center}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl\Erll\Trll\XTrll
\end{picture}$\:$.
\end{center}
Here, every evaluated node is colored black, and a node is crossed when a bound
condition was encountered. The only (minimal) solution created is represented
by the path substitute {\em marital status} $\rightarrow$ eliminate {\em age}
$\rightarrow$ substitute {\em position in household}. This corresponds to the
solution where {\em age} has to be altered to fix the record, and indeed
changing {\em age} from {\sf under-aged} to {\sf adult} in Eq.\
\eqref{eqrecord} will make the record fully valid. Note that the
branch-and-bound algorithm reduced the number of nodes to be evaluated from
$15$ to $8$ in this example.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Error localization with {\sf localizeErrors}}
\label{sslocalizeerrors}
\index{error localization!with {\sf localizeErrors}}
The function {\sf localizeErrors} applies the branch-and-bound algorithm to
determine the minimal weight error location for every record in a {\sf
data.frame}. The columns may be in {\sf character} or {\sf factor} format.  The
function has an identical interface for numerical data under linear edits and
categorical  data under categorical edits. It is implemented as an {\sf S3}
generic function, accepting either an {\sf editmatrix} or an {\sf editarray} as
the first argument and a {\sf data.frame} as the second argument. Further
arguments are a vector of variable weights, a maximum search time (in seconds)
to spend on a single record, a maximum weight and the maximum number of
variables which may be changed. The latter two arguments introduce extra bound
conditions in the branch-and-bound algorithm.
%
%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under-aged','adult')",
    "maritalStatus %in% c('unmarried','married','widowed','divorced')",
    "positionInHousehold %in% c('spouse', 'child', 'other')",
    "if( age == 'under-aged' ) maritalStatus == 'unmarried'",
    "if(positionInHousehold == 'spouse') maritalStatus == 'married'"
    )
)

(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under-aged','adult','adult' ),
    positionInHousehold=c('child','spouse','other')
))
set.seed(1)
localizeErrors(E,dat)
@
\caption{Localizing errors in a {\sf data.frame} of records. The data model is
as defined in Eqs. \eqref{eqdom1}-\eqref{eqdom3}.  The randseed is set before calling {\sf
localizeErrors} to make results reproducible. The third record has degeneracy 2,
which means that the chosen solution was drawn uniformly from two equivalent
solutions with weight 1.}
\label{RlocalizeErrors}
\end{Rcode}

Even when variables are weighted, the solution to the error localization
problem may not be unique. In those cases {\sf localizeErrors} will draw
uniformly from the set of lowest-weight solutions. The degeneracy (number of
equivalent solutions found) is reported in the output.

The result of a call to {\sf localizeErrors} is an object of class {\sf errorLocation}.
It contains a boolean matrix with error locations for each record as well as a status 
report containing degeneracies, solution weights run times and whether the maximum runtime
was exceeded. It also contains a timestamp (in the form of a {\sf Date} object) and the
name of the user running {\sf R}. Table \ref{tblErrorLocation} gives an overview of
the slots involved.
%
\input{tex/errorLocation.tex}

In Figure \ref{RlocalizeErrors} an example of the use of {\sf localizeErrors} is
given. The data model and rules are as in subsection \ref{sBandB}. The records
are given by
<<keep.source=false,echo=false>>=
(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under-aged','adult','adult' ),
    positionInHousehold=c('child','spouse','other')
))
@
Clearly, the first and third record disobey at least one rule while the second
record is valid. The first record can be repaired by adapting age and the
second record can be made consistent by changing either {\em position in
household} or {\em marital status}. In the latter case, both solutions have
equal weight and {\sf localizeErrors} has drawn one solution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\subsection{Error localization with {\sf errorLocalizer}}
\label{sserrorlocalizer}
\index{error localization!with {\sf errorLocalizer}}
The function {\sf errorLocalizer} gives more control over the error
localization process since it allows to parameterize the search separately for
each record. This can be useful, for example when reliability weights are
calculated for each record. Since {\sf errorLocalizer} is described
extensively in \cite{jonge:2011}, here we just discuss the example shown in
Figure \ref{RcatErrorLocalizer}.

The data model and edits are defined in Eqs.\ \eqref{eqdom1}-\eqref{eqdom3}.
For {\sf errorLocalizer}, a record must be offered as a named {\sf character}
vector.  A call to {\sf errorLocalizer} generates a {\sf backtracker} object
which contains all information necessary to start searching the binary tree.
After calling {\sf \$searchNext()} the weight and first found solution are
returned, while the {\sf backtracker} object stores some meta-information about
the process, most significantly the duration of the search. The parameter {\sf
\$maxDurationExceeded} indicates whether a solution was found within the
maximum time allowed for the search.  A second call yields an equivalent
solution and the third call returns {\sf NULL}, indicating that all minimal
weight solutions have been found. Finally, we note that with {\sf
\$searchAll()}, all solutions encountered during the branch-and-bound procedure
are returned.

%
\begin{Rcode}
<<keep.source=TRUE>>=
record <- c( 
    age = 'under-aged', 
    maritalStatus='married', 
    positionInHousehold='child'
)
el <- errorLocalizer(E,record)
el$searchNext()
el$duration
el$maxdurationExceeded
el$searchNext()
el$searchNext()
@
\caption{Finding errors with {\sf errorLocalizer}. The data model and edits in {\sf E} are as in
Figure \ref{RlocalizeErrors}.}
\label{RcatErrorLocalizer}
\end{Rcode}


\clearpage
\section{Conclusions}
This paper describes the theory and implementation of categorical edit
manipulation in {\sf R} package {\sf editrules}. Categorical restrictions may
be defined textually in standard {\sf R} syntax. Edits can be manipulated by
variable elimination and value substitution. Many other functionalities such as
feasibility checks, block detection and redundancy removal are implemented as
well.  Moreover, the package offers functionality to check records against
rules and can determine the location of errors based on the generalized
principle of Fellegi and Holt. 

Future work will include performance enhancements of error localization by
restating the problem as a mixed-integer problem, the treatment of mixed 
data and handling interdependent edits.


\bibliographystyle{chicago}
\bibliography{editrules}

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex



\end{document}


