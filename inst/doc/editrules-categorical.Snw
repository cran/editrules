%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}

\newtheorem{theorem}{Theorem}

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical and mixed data edits and error localization with the {\tt editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 2.0 fo the package will have
the full vignette. At the moment, functionality for treating categorical data has alpha status and is not public yet.}
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Defining and checking categorical constraints}
%We spend some time to define the boolean representation, since it eventually allows for an elegant
%elimination method.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Boolean representation of edits }
%A categorical record ${\bf v}$ is a combination of values from the
%cartesian product space
%\begin{equation}
%    D = D_1\times D_2\times\ldots\times D_n,
%\end{equation}
%where each $D_k$ is a finite set of $d_k$ categories. The total number of
%categories is $d = \sum_{k=1}^n d_k$.
%Categorical records can be represented as  a boolean vector. A boolean
%vector of dimension $d$ is an element of the boolean algebra 
%\begin{equation}
%\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
%\end{equation}
%where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
%logical operators work elementwise on their operands. To represent a record
%${\bf v}$, assign to every category $i$ in $D_k$ a unique standard 
%basisvector $\vec{\delta}_k(i)$ of $\mathbb{B}^{d_k}$. 
%The boolean representation $\rho({\bf v})$ of the full record reads
%%
%\begin{equation}
%    {\bf v} \xrightarrow{\rho} \vec{\delta}_{1}(v_1)\oplus\vec{\delta}_{2}(v_2)\oplus\ldots\oplus\vec{\delta}_n(v_n).
%\end{equation}
%An edit $e$ is a subset of $D$, which can be written as the cartesian product
%\begin{equation}
%    e = {\bf e}_1\times{\bf e}_2\ldots\times{\bf e}_n,
%    \label{eqDefEdit}
%\end{equation}
%where each ${\bf e}_k\subseteq D_k$.  The interpretation of an edit is that if
%a record ${\bf v}\in e$, then ${\bf v}$ is considered invalid.  We say that a
%record {\em fails} an edit when it satisfies Eq.\ \eqref{eqCheckEdit}.  A
%variable $v_i$ is {\em involved} in an edit if ${\bf e}_i\subset D_j$ is a
%proper subset.  Conversely, we say that $e$ contains $v_k$ if $v_k$ is involved
%in $e$. A variable $v_k$ for which ${\bf e}_k=D_k$ is not contained in $e$, or:
%$e$ does not involve $v_k$. An edit is redundant if it is the subset of another
%edit.
%
%Since every category $i$ of $D_k$ is mapped to a unique basis vector
%$\vec{\delta}_k(i)$,  edits have a boolean representation $\rho(e)$, given by
%\begin{eqnarray}
%    e &\xrightarrow{\rho}&
%    \Lor_{i\in{\bf e}_1}\vec{\delta}_1(i)\oplus
%    \Lor_{i\in{\bf e}_2}\vec{\delta}_2(i)\oplus\ldots
%    \oplus\Lor_{i\in{\bf e}_k}\vec{\delta}_n(i),
%\end{eqnarray}
%which may simply be written as
%\begin{equation}
%    \rho(e) ={\bf a} = {\bf a}_1\oplus{\bf a}_2\oplus\ldots\oplus{\bf a}_n.
%\label{EqRhoE}
%\end{equation}
%One may think of the ${\bf a}_k$ as boolean vectors indicating which elements of $D_k$
%occur in ${\bf e}_k$.
%
%
%
%
%\subsection{The {\tt editarray} object}
%In the {\tt editrules} package, a set of categorical edits is represented as an {\tt editarray}
%object. Formally, we denote an edit array $E$ for $n$ categorical variables and $m$ edits as
%\begin{equation}
%    E = \langle {\bf A}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
%    d = \sum_{k=1}^n d_k.
%    \label{eqEditarray}
%\end{equation}
%Here, each row of ${\bf A}$ contains the boolean representation of one edit,
%and the $d_k$ denote the number of categories of each variable. The brackets
%are used to indicate a combination of objects. The {\tt editarray} is the
%central object for computing with catgegorical edits, just like the {\tt
%editmatrix} is the central object for computations with linear edits.
% 
%%
%\begin{Rcode}
%<<keep.source=true>>=
%editarray(c(
%    "gender %in% c('male','female')",
%    "pregnant %in% c('yes','no')",
%    "if (gender == 'male') pregnant == 'no'"
%    )
%)
%@
%\caption{Defining a simple {\tt editarray} with the {\tt editarray} function. 
%Column heads of the array are abbreviated versions of variable names and categories
%seperated by a colon (by default). When printed to screen, a {\tt character} version
%of the edits is shown as well, for readability.
%}
%\label{Reditarray}
%\end{Rcode}
%%
%
%It is both tedious and error prone to define and maintain an editarray by hand.
%In practice, categorical edits are usually stated verbosely, such as: ``if the
%gender is male, then pregnant must be false'', or ``if you are under-aged, you
%cannot be married''. To facilitate the definition of edit arrays, {\tt
%editrules} is equipped with a parser, which takes R-statements in {\tt
%character} format, and translates them to an {\tt editarray}.
%
%Figure \ref{Reditarray} shows a simple example of defining an editmatrix with
%the editrules package.  The first two edits in Figure \ref{Reditarray} define
%the data model. The {\tt editarray} function derives the datamodel based on the
%variable names and categories it finds in the edits, whether they are
%univariate (defining domains) of multivariate. This means that if all possible
%variables and categories are mentioned in the multivariate edits, the correct
%datamodel will be derived as well. It is important to note that most functions
%working with categorical edits, assume that the full datamodel is represented
%in the columns of an {\tt editarray}. The function {\tt datamodel} accepts an
%edit array as input and returns an overview of variables and their categories.
%
%When printed to the screen, the boolean array is shown with column heads of the form
%\begin{quote}
%{\tt <variable><separator><category>}, 
%\end{quote}
%where both variable names and categories are abbreviated for readability, and
%the standard separator is a colon ({\tt :}). The separator may not occur as a
%symbol in either variable or category name, and its value can be determined by
%passing a custom {\tt sep} argument to {\tt editarray}.
%
%Internally, {\tt editarray} uses the {\sf R} internal {\tt parse} function to
%transform the {\tt character} expressions to a parse tree, which is
%subsequently traversed recursively to derive the entries of the editmatrix. The
%opposite is also possible. The {\sf R} internal function {\tt as.character} has
%been overloaded to derive a {\tt character} representation from a boolean
%representation. When printed to the screen, both the boolean and textual
%representation are shown.
%
%The character expressions that can be read by {\tt editarray}, such as
%\begin{quote}
%\verb+"if ( gender == 'male' ) pregnant = 'no'"+ 
%\end{quote}
%follows standard {\sf R} syntax, which should be already familliar to the
%reader. Note that double quotes are used to enclose the whole string, while
%single quotes are used for category names. Table \ref{tabOperators} shows
%which operators and functions can be used to specify categorical edit rules.
%%
%\begin{table}
%\begin{threeparttable}
%\caption{Functions and operators that may be used to define edits with {\tt editarray} }
%\label{tabOperators}
%\begin{tabular}{ll}
%\hline
%Operator & Description\\
%\hline
%{\tt \%in\%} & Set membership$^*$  \\
%{\tt ==}     & Equality$^*$ \\
%{\tt if( <condition> ) <expression> } & conditional statement\\
%{\tt c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\tt character} or {\tt logical}\\
%{\tt \&\&}    & logical {\sc and}\\
%{\tt ||}      & logical {\sc or}\\
%{\tt !}       & logical {\sc not}\\
%\hline
%\end{tabular}
%$^*${\small Right-hand side is evaluated.}
%\end{threeparttable}
%\end{table}
%%
%%
%Categories may be litaral characters, or booleans.  It is worth noting that
%expressions on the right hand side of the {\tt \%in\%}  and {\tt ==} operators
%are evaluated. One useful application of this is that the categories, or data
%model can be defined outside of the edits:
%%
%<<keep.source=true>>=
%xval <- letters[1:4]
%yval <- c(TRUE,FALSE)
%editarray(c( "x %in% xval","y %in% yval","if ( x %in% c('a','b') ) !y "))
%@
%%
%The above example also illustrates the use of boolean categories.
%
%
%
%\subsection{Basic manipulations and edit checking}
%Table \ref{tabBasicfunctions} shows lists basic functions of {\tt editmatarray}
%objects.  The {\tt datamodel} function retrieves the variables and categories
%in an edit array, and returns them as a two-column {\tt data.frame}.
%
%With {\tt getArr} the array part of an {\tt editarray} can be retrieved. The
%other contents of an {\tt editarrray} are of no use for users and are {\tt
%editrules} internal.
%
%The function {\tt violatedEdits} takes a {\tt data.frame} or named {\tt
%character} vector as input and returns a logical array where each row indicates
%which edits are violated by the input data.
%The relation 
%\begin{equation}
%    {\bf v}\in{e}\Leftrightarrow \sum_{j=1}^d(\rho({\bf v})\land\rho({ e}))_j = n,
%    \label{eqCheckEdit}
%\end{equation}
%is used to test the validity of records. Here, $n$ is the number of variables
%and the sum is over the coefficients of $\rho({\bf v})\land\rho({ e})$,
%interpreted as numbers. The relation holds since a record can have at most one
%coefficient per variable equal to $1$ in the boolean representation.
%
%
%
%
%\begin{table}
%\begin{threeparttable}
%\caption{Basic functions for objects of class {\tt editarray}. Only mandatory
%arguments are shown, refer to the built-in documentation for optional
%arguments.}
%\label{tabBasicfunctions}
%\begin{tabular}{ll}
%\hline
%Function        & description \\
%\hline
%{\tt datamodel(E)}           & get datamodel \\
%{\tt getArr}                 & get array ${\bf A}$\\
%{\tt as.data.frame(E)}       & coerce to {\tt data.frame}\\
%{\tt as.character(E)}        & coerce to {\tt character} vector\\
%{\tt violatedEdits(E,x)}     & check which edits are violated by {\tt x}\\
%{\tt duplicated(E)}          & detect duplicate edits\\
%{\tt isObviouslyRedundant(E)}& detect simple redundancies\\
%{\tt isSubset(E)}            & detect edits contained in another edit\\
%{\tt isObviouslyInfeasible}  & detect if {\tt E} contains a contradiction\\ 
%{\tt substValue}             & substitute a value\\
%\hline
%\end{tabular}
%\end{threeparttable}
%\end{table}
%
%
%\subsection{Obvious redundancy and infeasibility}
%When manipulating edit sets, edits may arise which have ${\bf e}_k=\varnothing$
%for one of the variables. A record can never be an element of such an edit, and
%such edits are therefore redundant. Such redundancies are easily detected since
%all coefficients of the corresponding ${\bf a}_k$ (Eq.\ \eqref{EqRhoE}) are
%equal to zero for these edits. The function {\tt isObviouslyRedundant} returns
%a logical vector indicating which edits in an editarray have become obviously
%redundant.  If an edit is a subset of another edit, it is also redundant. The
%function {\tt isSubset} returns a logical, indicating if an edit is a subset of
%any other edit in the {\tt editarray}.
%
%Manipulations may also lead to edits of the form $e=D$, in which case every possible
%record is invalid, and the editarray has become impossible to satisfy. The function
%{\tt isObviouslyInfeasible} detects whether any such edits are present.They can be 
%detected by checking if $\sum_{j=1}^d\rho(e)_j=d$.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Manipulation of categorical restrictions}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Value substitution}
%Substituting a value in an editarray consists of two steps. First, all edits
%that exclude the value which is to be subsituted are removed. They have become
%redundant, since no record can be contained in such edits. Second, if variable
%$k$ is substituted by category $j\in D_k$, for every remaining edit, all
%coefficients of ${\bf a}_k$ except the $j$th are set to 0.  The function {\tt
%substValue} can be used to substitute one or more values in an {\tt editarray}.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Variable elimination by category resolution}
%Suppose $e_1$ and $e_2$ are edits, with boolean representations ${\bf a}$ and
%${\bf b}$ respectively.  We define the {\em resolution operator} $\res_j$ as
%follows:
%\begin{eqnarray}
%    {\bf a} \res_j {\bf b} = 
%    (a_1\land b_1,\ldots,a_{j-1}\land b_{j-1},a_{j}\lor b_{j},a_{j+1}\land b_{j+1},\ldots,a_d\land b_d).
%\end{eqnarray}
%Observe that this operator has the following properties, relevant for record checking.
%\begin{eqnarray}
%   \rho({\bf v})\in {\bf a}\res_j{\bf b} &\Rightarrow& \rho({\bf v})\in{\bf a} \lor \rho({\bf v})\in{\bf b}\\
%   \rho({\bf v})\in {\bf a} &\Rightarrow& \rho({\bf v})\in{\bf a}\res_j{\bf b} \lor {\bf a}\res_j{\bf b}=\varnothing\\
%   a_j = b_j &\Rightarrow& {\bf a}\res_j{\bf b} = {\bf a}\land {\bf b} 
%    \label{eqRedundant}
%\end{eqnarray}
%The operator is called resolution operator since its action strongly resembles
%a resolution operation from formal logic.  If $a_j= \lnot b_j$, the operator
%``resolves'' or eliminates one of the categories $j\in D$. That is, the
%resulting edit (if any) is guaranteed to have $({\bf a}\res_j{\bf
%a})_j=\textrm{\sc true}$.  The resolution operator is only defined on the
%boolean representation of edits, and has no direct equivalent in the
%set-theoretical representation of edits (Eq.\ \eqref{eqDefEdit}).  The only
%exception is the special case of Eq.\ \eqref{eqRedundant}.  When
%$a_j=b_j=\textrm{\sc true}$, the resulting edit is the intersection of the
%original edits, in which case the resulting edit is redundant. 
%
%By substitution in the definition, it can be shown that the resolution operator is
%symmetrical, associative and idempotent. As a reminder, these properties are defined
%as follows.
%\begin{equation}
%\begin{array}{ll}
%\textrm{symmetry:}  &{\bf a}\res_j{\bf b} = {\bf b} \res_j {\bf a} \\
%\textrm{associativity:}& ({\bf a}\res_j{\bf b})\res_j {\bf c} = {\bf a}\res_j({\bf b}\res_j {\bf c}).\\
%\textrm{idempotency:} &{\bf a}\res_j {\bf a} = {\bf a}.
%\end{array}
%\end{equation}
%The following distributive property also holds
%\begin{equation}
%\begin{array}{ll}
%\textrm{distributivity:}& ({\bf a}\res_i{\bf b})\res_j{\bf c} = ({\bf a}\res_j{\bf c})\res_i({\bf b}\res_j{\bf c}).
%\end{array}
%\end{equation}
%
%The resolution operator can be used to eliminate a category $j$ from a set of
%edits as follows. First, collect all pairs of edits $({\bf a}^+,{\bf a}^-)$
%which have $a^+_j=\lnot b^+_j$. Next, a new set of edits is created, consisting
%of the ${\bf a}^+$ and every combination ${\bf a}^+\res_j{\bf a}^-$. A variable
%$v_k$ can be eliminated by applying this procedure repeatedly to all categories
%of a variable. The resulting boolean representation of the edits have
%$a_j=\textrm{\sc true}$ for all $j\in D_k$. In set-theoretical terms this means
%that for every resulting edit ${\bf e}_k=D_k$. Or in words: it does not depend
%on the value of $v_k$ if a record ${\bf v}$ fails one of the resulting edits.
%
%
%
%%
%%
%\begin{algorithm}[t]
%\caption{{\sc eliminate($E$,$j$)}}
%\label{eliminate}
%\begin{algorithmic}
%    \Require an {\tt editarray} $E=\langle{\bf A}\rangle$, a variable index $k$
%    \For{$j\in D_k$}
%    \State $A^+ = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc true}\}$
%    \State $A^- = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc false}\}$ 
%    \State ${\bf A}\leftarrow A^+$
%    \State $i\leftarrow |A^+|$
%    \For{$({\bf a},{\bf b})\in A^+\times A^-$}
%    \State $i \leftarrow i+1$
%    \State ${\bf A}_{i}\leftarrow {\bf a}\res_j{\bf b}$
%    \EndFor
%    \EndFor
%    \Ensure {\tt editarray} $\langle{\bf A}\rangle$ with variable $j$ eliminated
%\end{algorithmic}
%\end{algorithm}
%
%
%\section{Error localization in categorical data}
%\label{secErrLocCat}



\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}
